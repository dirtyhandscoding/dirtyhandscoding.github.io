<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Dirty hands coding</title><link>https://dirtyhandscoding.github.io/</link><description></description><lastBuildDate>Wed, 02 May 2018 20:07:00 +0700</lastBuildDate><item><title>Blog migrated to Pelican and GitHub pages</title><link>https://dirtyhandscoding.github.io/posts/blog-migrated-to-pelican-and-github-pages.html</link><description>&lt;p&gt;This article is a sort of report about blog migration.&lt;/p&gt;
&lt;h2 id="on-wordpresscom"&gt;&lt;a class="toclink" href="#on-wordpresscom"&gt;On wordpress.com&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Initially, I started &lt;a href="http://dirtyhandscoding.wordpress.com"&gt;this blog on wordpress.com&lt;/a&gt;. I chose wordpress.com thinking that I only need a small personal blog and I can easily live without any advanced features. I was pretty sure that I will post only technical articles, and do so quite rarely, so I searched for a free solution and wordpress.com was a good fit. And the experience was quite good in general: I did not have to configure anything, just choose a classic theme and go on writing.&lt;/p&gt;
&lt;p&gt;A problem which I noticed rather quickly is that the width of the text in my blog was way too small. The amount of text fitting into one line was small, and it was especially ugly for source code fragments. When I wanted to post a piece of code from somewhere, I had to add split lines into pieces, so that the whole code fits and no scroll bar appears.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Wed, 02 May 2018 20:07:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2018-05-02:/posts/blog-migrated-to-pelican-and-github-pages.html</guid><category>blog</category><category>pelican</category><category>gh-pages</category></item><item><title>Vectorizing small fixed-size sort</title><link>https://dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html</link><description>&lt;p&gt;After a long break, I can finally return to the topic which was started in the &lt;a href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html"&gt;previous blog post&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Imagine that we have a small array of compile-time constant size with integers. For instance, N = 32. And we want to sort it as fast as possible. What is the best solution for this problem?&lt;/p&gt;
&lt;p&gt;The wisest of you would suggest simply using std::sort, because every modern implementation of it is well-optimized and contains special handling of small subarrays to accelerate the generic quicksort algorithm. The ones who don't trust libraries would suggest using insertion sort: this is the algorithm usually used to handle small cases in std::sort. The performance geeks and regular stackoverflow visitors would definitely point to sorting networks: every question like "the fastest way to sort K integers" ends up with a solution based on them (&lt;a href="https://stackoverflow.com/questions/2786899/fastest-sort-of-fixed-length-6-int-array"&gt;N=6&lt;/a&gt;, &lt;a href="https://stackoverflow.com/questions/32172144/fastest-way-to-sort-10-numbers-numbers-are-32-bit"&gt;N=10&lt;/a&gt;, &lt;a href="https://stackoverflow.com/questions/19790522/very-fast-sorting-of-fixed-length-arrays-using-comparator-networks"&gt;what&lt;/a&gt;, &lt;a href="https://stackoverflow.com/questions/3901079/how-does-a-sorting-network-beat-generic-sorting-algorithms"&gt;why&lt;/a&gt;). I'm going to present a much less known way to sort small arrays of 32-bit keys, with performance comparable to sorting networks.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Fri, 05 Jan 2018 23:26:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2018-01-05:/posts/vectorizing-small-fixed-size-sort.html</guid><category>cmov</category><category>simd</category><category>sort</category></item><item><title>Addendum to Performance comparison: linear search vs binary search</title><link>https://dirtyhandscoding.github.io/posts/addendum-to-performance-comparison-linear-search-vs-binary-search.html</link><description>&lt;p&gt;The &lt;a href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html"&gt;previous blog post&lt;/a&gt; got some attention and several good questions and suggestions. So I feel that I should sum up the main points noted by readers. Since the main article is already too long, I decided to keep all of this as a separate post.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Tue, 29 Aug 2017 02:21:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2017-08-29:/posts/addendum-to-performance-comparison-linear-search-vs-binary-search.html</guid><category>binary search</category><category>cmov</category></item><item><title>Performance comparison: linear search vs binary search</title><link>https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html</link><description>&lt;p&gt;While working on an implementation of merge sort promised in &lt;a href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html"&gt;the previous article&lt;/a&gt;, I realized that I'd like to use one neat little thing, which is worth its own post. It is a simple strategy for sorting or doing comparison-based tasks, which works wonderfully when input data is small enough.&lt;/p&gt;
&lt;p&gt;Suppose that we have a very small array and we want to sort it as fast as possible. Indeed, applying some fancy &lt;em&gt;O(N log N)&lt;/em&gt; algorithm is not a good idea: although it has optimal asymptotic performance, its logic is too complicated to outperform simple bubble-sort-like algorithms which take &lt;em&gt;O(N^2)&lt;/em&gt; time instead. That's why every well-optimized sorting algorithm based on quicksort (e.g. std::sort) or mergesort includes some simple quadratic algorithm which is run for sufficiently small subarrays like N &amp;lt;= 32.&lt;/p&gt;
&lt;p&gt;What exactly should we strive for to get an algorithm efficient for small N? Here is the list of things to look for:
&lt;ol&gt;
  &lt;li&gt;Avoid branches whenever possible: unpredictable ones are very slow.&lt;/li&gt;
  &lt;li&gt;Reduce data dependency: this allows to fully utilize processing units in CPU pipeline.&lt;/li&gt;
  &lt;li&gt;Prefer simple data access and manipulation patterns: this allows to vectorize the algorithm.&lt;/li&gt;
  &lt;li&gt;Avoid complicated algorithms: they almost always fail on one of the previous points, and they sometimes do too much work for small inputs.&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;
&lt;p&gt;I decided to start investigating a simpler problem first, which is solved by std::lower_bound: &lt;u&gt;given a sorted array of elements and a key, find index of the first array element greater or equal than the key&lt;/u&gt;. And this investigation soon developed into a full-length standalone article.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Fri, 25 Aug 2017 21:02:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2017-08-25:/posts/performance-comparison-linear-search-vs-binary-search.html</guid><category>binary search</category><category>cmov</category><category>iaca</category><category>simd</category></item><item><title>Vectorizing std::merge with vpermd from AVX2 and lookup table</title><link>https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html</link><description>&lt;p&gt;Recently I stumbled upon &lt;a href="https://stackoverflow.com/questions/43253036/computing-size-of-symmetric-difference-of-two-sorted-arrays-using-simd-avx"&gt;a question on stackoverflow&lt;/a&gt;, which asked how to vectorize computing symmetric difference of two sorted int32 arrays using AVX2. I decided to try doing it myself, and this post is about what I achieved. Of course, the best way to compute symmetric difference of sorted sets is by running ordinary &lt;a href="https://en.wikipedia.org/wiki/Merge_algorithm"&gt;merge algorithm&lt;/a&gt; (e.g. with std::merge) for the arrays plus some simple postprocessing. I'll concentrate only on the generic merging algorithm here.&lt;/p&gt;
&lt;p&gt;I'll handle 32-bit integer keys only. Having keys of larger size would reduce significantly the efficiency of the algorithm (as usual with vectorization). Using 32-bit floating point keys is not much different from using integer keys; moreover, sorting 32-bit floats can be easily reduced to sorting 32-bit integers, which is often used to run radix sort on floating point data (see &lt;a href="http://stereopsis.com/radix.html"&gt;this&lt;/a&gt; and &lt;a href="http://codercorner.com/RadixSortRevisited.htm"&gt;that&lt;/a&gt;). Also I'll briefly discuss the case when 32-bit values are attached to 32-bit keys (sorting without values is pretty useless in practice).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Wed, 02 Aug 2017 23:20:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2017-08-02:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html</guid><category>avx</category><category>simd</category><category>sort</category></item><item><title>Doom 3: C++ enhanced RTTI and memory debugging</title><link>https://dirtyhandscoding.github.io/posts/doom-3-c-enhanced-rtti-and-memory-debugging.html</link><description>&lt;p&gt;Although Doom 3 was released 13 years ago, there is still of lot of interesting stuff to find in it. The main reason for that is: it was developed in the time of changes. The ID software team had just moved from C to C++ (using Visual C++ 6). Graphic cards were moving from fixed pipeline to programming pipeline, CPUs were getting SIMD extensions. All of this caused a lot of diversity in the code: crazy mix of C++/C/asm code, several renderer backends, code acceleration for MMX/SSE/AltiVec (yeah, Macs used PowerPC at that time). Not to mention tons of scripts and defs, including C++-like scripting language, and in-game GUI system.&lt;/p&gt;
&lt;p&gt;I have to deal with Doom 3 engine in the context of &lt;a href="http://www.thedarkmod.com"&gt;The Dark Mod&lt;/a&gt; (TDM for short).&lt;/p&gt;
&lt;p&gt;This article is about &lt;strong&gt;memory debugging&lt;/strong&gt; configuration in Doom 3 SDK (more precisely, "Debug with inlines and memory log").&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dirtyhandscoding</dc:creator><pubDate>Wed, 19 Jul 2017 10:49:00 +0700</pubDate><guid isPermaLink="false">tag:dirtyhandscoding.github.io,2017-07-19:/posts/doom-3-c-enhanced-rtti-and-memory-debugging.html</guid><category>idtech4</category><category>memory debugging</category></item></channel></rss>