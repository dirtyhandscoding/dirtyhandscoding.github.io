<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dirty hands coding - Comments: Vectorizing std::merge with vpermd from AVX2 and lookup table</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/" rel="alternate"></link><link href="/feeds/comment.vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.atom.xml" rel="self"></link><id>https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/</id><updated>2017-08-27T23:07:00+07:00</updated><entry><title>Posted by: Morwenn</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/#comment-3md" rel="alternate"></link><published>2017-08-27T23:07:00+07:00</published><updated>2017-08-27T23:07:00+07:00</updated><author><name>Morwenn</name></author><id>tag:dirtyhandscoding.github.io,2017-08-27:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html//comment-3md</id><summary type="html">&lt;p&gt;In the end, your taken solution goes in the same way, but further, truly solves the problem. At first I was surprised that you didn’t use a binary search to find the greatest element of a collection in the other collection, but your latest post pretty much covers the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the end, your taken solution goes in the same way, but further, truly solves the problem. At first I was surprised that you didn’t use a binary search to find the greatest element of a collection in the other collection, but your latest post pretty much covers the linear vs binary search question.&lt;/p&gt;
&lt;p&gt;I’m surprised that your branchless implementation is faster though, considering that the last time I tried to make a branchless merge, it was terribly slower than branchy version (see SO post). That said, after having read your post, it becomes clearer: the loop condition still depended on the result of the loop, so the branch wasn’t the main issue in the first place. I should try it again.&lt;/p&gt;
&lt;p&gt;Anyway, if you ever write that mergesort article, I’ll be happy to read it ^^&lt;/p&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/q/41129442/1364752"&gt;https://stackoverflow.com/q/41129442/1364752&lt;/a&gt;&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/#comment-2md" rel="alternate"></link><published>2017-08-27T19:38:00+07:00</published><updated>2017-08-27T19:38:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2017-08-27:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html//comment-2md</id><summary type="html">&lt;p&gt;I’m glad you liked it!&lt;/p&gt;
&lt;p&gt;Yes, you can merge the first &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements without checking where the pointers are, and then use slower &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt; condition for the rest of the work. For the most likely case of equally-sized arrays, it would cope only with …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I’m glad you liked it!&lt;/p&gt;
&lt;p&gt;Yes, you can merge the first &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements without checking where the pointers are, and then use slower &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt; condition for the rest of the work. For the most likely case of equally-sized arrays, it would cope only with 50% of the issue (regardless of elements order). I guess my perfectionism does not like that =) The things I suggested fix the problem almost completely, except for maybe pathologically ordered inputs.&lt;/p&gt;
&lt;p&gt;Hopefully I'll implement merge sort on top of the suggested merge algorithm, but I'm afraid it won't happen soon =(&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Posted by: Morwenn</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/#comment-1md" rel="alternate"></link><published>2017-08-26T19:29:00+07:00</published><updated>2017-08-26T19:29:00+07:00</updated><author><name>Morwenn</name></author><id>tag:dirtyhandscoding.github.io,2017-08-26:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html//comment-1md</id><summary type="html">&lt;p&gt;Hi, I found your article very interesting (and being a code-stealer, I might borrow some ideas to improve some of my algorithms). I also tried to improve a simple merge algorithm once or twice, and came up with a few tricks. Condiering how smart some of the ideas you describe …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hi, I found your article very interesting (and being a code-stealer, I might borrow some ideas to improve some of my algorithms). I also tried to improve a simple merge algorithm once or twice, and came up with a few tricks. Condiering how smart some of the ideas you describe are, I’m surprised that you didn’t describe one the simplest tricks I use: since we know the size of the collections, we know that we will have to move at least &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements from each of the original collections, so we can do a blind loop from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt;, then the usual loop that checks for &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt;. In order to do that, I actually copy pointers that I increment instead of incrementing the indices, so it's a bit different. I feel that I suck at explaining, so you could just have a look at the code at the end of the algorithm. The trick ensures that the first loop condition is trivial rather than repeatedly checking for the values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; that are unpredictable at every iteration.&lt;/p&gt;
&lt;p&gt;Anyway, that was a great article; really interesting. Kudos! &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97"&gt;https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97&lt;/a&gt;&lt;/p&gt;</content><category term="Uncategorized"></category></entry></feed>