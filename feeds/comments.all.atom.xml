<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dirty hands coding - All Comments</title><link href="https://dirtyhandscoding.github.io/" rel="alternate"></link><link href="/feeds/comments.all.atom.xml" rel="self"></link><id>https://dirtyhandscoding.github.io/</id><updated>2024-08-31T15:18:00+02:00</updated><entry><title>Blog migrated to Pelican and GitHub pages - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/blog-migrated-to-pelican-and-github-pages.html#comment-2md" rel="alternate"></link><published>2024-08-31T15:18:00+02:00</published><updated>2024-08-31T15:18:00+02:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2024-08-31:/posts/blog-migrated-to-pelican-and-github-pages.html/comment-2md</id><summary type="html">&lt;p&gt;Yes, email-based comments are the most "static" ones.
But now (almost 6 years later) I can also mention some downsides:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; It takes long time from when comment is sent to when it appears on website.
It means fast-paced conversations in comments are simply impossible.
Also, the reader might be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Yes, email-based comments are the most "static" ones.
But now (almost 6 years later) I can also mention some downsides:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; It takes long time from when comment is sent to when it appears on website.
It means fast-paced conversations in comments are simply impossible.
Also, the reader might be confused on whether his comment is not yet applied or got lost somewhere.
I guess reader does not get a notification about reply, unless he uses RSS/atom feed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; Author takes the maintenance burden to be ready to update the blog at any moment.
For instance, I have just moved to a new country.
When I received your comment, I realized that the most recent version of my blog existed only on my main PC, which was still packaged.
That's why your comment appeared 3 week later than it should =)
Data loss can be a problem too... I guess should finally find some mercurial hosting.
Also I did not touch the blog in several years, so I had to dive in and upgrade some stuff.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Blog migrated to Pelican and GitHub pages - Posted by: Paul Lee</title><link href="https://dirtyhandscoding.github.io/posts/blog-migrated-to-pelican-and-github-pages.html#comment-1md" rel="alternate"></link><published>2024-08-10T00:06:00-04:00</published><updated>2024-08-10T00:06:00-04:00</updated><author><name>Paul Lee</name></author><id>tag:dirtyhandscoding.github.io,2024-08-10:/posts/blog-migrated-to-pelican-and-github-pages.html/comment-1md</id><summary type="html">&lt;p&gt;I found this excellent description when searching for live uses of the Python package, pelican_comment_system.
I'm intrigued by the solution. It feels retro-minimalist and complements the philosophy of static sites.
I like the fact that it's available directly within the Python ecosystem.
Thanks for thoroughly documenting your experiences and innovations …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I found this excellent description when searching for live uses of the Python package, pelican_comment_system.
I'm intrigued by the solution. It feels retro-minimalist and complements the philosophy of static sites.
I like the fact that it's available directly within the Python ecosystem.
Thanks for thoroughly documenting your experiences and innovations.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: Touisteur</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-13md" rel="alternate"></link><published>2021-08-11T13:12:00+02:00</published><updated>2021-08-11T13:12:00+02:00</updated><author><name>Touisteur</name></author><id>tag:dirtyhandscoding.github.io,2021-08-11:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-13md</id><content type="html">&lt;p&gt;Thanks for the link!&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Vectorizing small fixed-size sort - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html#comment-2md" rel="alternate"></link><published>2021-08-11T11:46:00+07:00</published><updated>2021-08-11T11:46:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2021-08-11:/posts/vectorizing-small-fixed-size-sort.html/comment-2md</id><summary type="html">&lt;p&gt;Only SSE is used in the article, not even AVX.
The code repo contains AVX implementation, but it works slower than SSE.
The size of the problem is very small, so it is hard to benefit from wider vectorization, and for greater size vectorized code will lose to &lt;em&gt;O(N …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Only SSE is used in the article, not even AVX.
The code repo contains AVX implementation, but it works slower than SSE.
The size of the problem is very small, so it is hard to benefit from wider vectorization, and for greater size vectorized code will lose to &lt;em&gt;O(N log N)&lt;/em&gt; solutions.
So, I don't think AVX-512 will help here.&lt;/p&gt;
&lt;p&gt;Also, I think AVX-512 is still unavailable in consumer CPUs, so I cannot test it anyway.&lt;/p&gt;
&lt;p&gt;As for use case, I don't have one.
I did it purely for fun after seeing many questions on stackoverflow.
Looking at the links I provided at the beginning of the article, question posters did not describe their use cases too.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-12md" rel="alternate"></link><published>2021-08-11T11:26:00+07:00</published><updated>2021-08-11T11:26:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2021-08-11:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-12md</id><content type="html">&lt;p&gt;Yes, indeed it can be used to compute order statistics.&lt;/p&gt;
&lt;p&gt;For instance, see it &lt;a href="https://stackoverflow.com/questions/33307957/calling-stdnth-element-function-extremely-frequently/33325864#33325864"&gt;applied to median of 23 elements&lt;/a&gt;.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Vectorizing small fixed-size sort - Posted by: Touisteur</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html#comment-1md" rel="alternate"></link><published>2021-08-11T00:54:00+02:00</published><updated>2021-08-11T00:54:00+02:00</updated><author><name>Touisteur</name></author><id>tag:dirtyhandscoding.github.io,2021-08-11:/posts/vectorizing-small-fixed-size-sort.html/comment-1md</id><summary type="html">&lt;p&gt;Neat! It makes me think of prefix sums and all the things you can use them for.&lt;/p&gt;
&lt;p&gt;I'm thinking for a selection algorithm the 'moving the result cells in their new position' can be forsaken, but I'm wondering how it would end then instead.&lt;/p&gt;
&lt;p&gt;Once more a really excellent, excellent …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Neat! It makes me think of prefix sums and all the things you can use them for.&lt;/p&gt;
&lt;p&gt;I'm thinking for a selection algorithm the 'moving the result cells in their new position' can be forsaken, but I'm wondering how it would end then instead.&lt;/p&gt;
&lt;p&gt;Once more a really excellent, excellent post. Can't wait to see what avx512 could bring here.&lt;/p&gt;
&lt;p&gt;Pure curiosity (and to connect dots): Can you (please?) share your use case(s?) for wanting to sort lots of small arrays so fast?&lt;/p&gt;
&lt;p&gt;Thanks a lot.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: Touisteur</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-11md" rel="alternate"></link><published>2021-08-11T00:45:00+02:00</published><updated>2021-08-11T00:45:00+02:00</updated><author><name>Touisteur</name></author><id>tag:dirtyhandscoding.github.io,2021-08-11:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-11md</id><summary type="html">&lt;p&gt;Hi, I'm wondering whether this technique could be used for selection tasks. Like 'find the N-th-biggest (or -smallest) element of a small (up to 64-elements) unsorted array' without sorting/moving the original data.&lt;/p&gt;
&lt;p&gt;For each &lt;code&gt;a[i]&lt;/code&gt; of the array &lt;code&gt;a[64]&lt;/code&gt; count (from 0 to 63) the number of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hi, I'm wondering whether this technique could be used for selection tasks. Like 'find the N-th-biggest (or -smallest) element of a small (up to 64-elements) unsorted array' without sorting/moving the original data.&lt;/p&gt;
&lt;p&gt;For each &lt;code&gt;a[i]&lt;/code&gt; of the array &lt;code&gt;a[64]&lt;/code&gt; count (from 0 to 63) the number of elements bigger (or smaller) than &lt;code&gt;a[i]&lt;/code&gt;. Then locate the one with value N with some other magic...&lt;/p&gt;
&lt;p&gt;Very, very insightful and inspiring.. Thanks!&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: RyanB</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-10md" rel="alternate"></link><published>2019-05-15T10:06:00+07:00</published><updated>2019-05-15T10:06:00+07:00</updated><author><name>RyanB</name></author><id>tag:dirtyhandscoding.github.io,2019-05-15:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-10md</id><summary type="html">&lt;p&gt;I came up with a little trick that seems to be 33% faster on my machine, for my use case (and it doesn’t require sorting):
In linear_search_scalar(), replace &lt;code&gt;arr[i] &amp;lt; key&lt;/code&gt; with &lt;code&gt;(arr[i] == key) * i&lt;/code&gt;.
Presumably, this allows the loop to just do one non-trivial addition operation (or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I came up with a little trick that seems to be 33% faster on my machine, for my use case (and it doesn’t require sorting):
In linear_search_scalar(), replace &lt;code&gt;arr[i] &amp;lt; key&lt;/code&gt; with &lt;code&gt;(arr[i] == key) * i&lt;/code&gt;.
Presumably, this allows the loop to just do one non-trivial addition operation (or none if the item isn't to be found) instead of multiple.
Give it a try!&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: Dr. Khalid Omar Thabit</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-9md" rel="alternate"></link><published>2018-11-14T06:23:00+07:00</published><updated>2018-11-14T06:23:00+07:00</updated><author><name>Dr. Khalid Omar Thabit</name></author><id>tag:dirtyhandscoding.github.io,2018-11-14:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-9md</id><content type="html">&lt;p&gt;If prefetch instruction was used with the AVX2 in linear search it would even improve the speed.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: Krishty</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-8md" rel="alternate"></link><published>2018-04-01T02:35:00+07:00</published><updated>2018-04-01T02:35:00+07:00</updated><author><name>Krishty</name></author><id>tag:dirtyhandscoding.github.io,2018-04-01:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-8md</id><content type="html">&lt;p&gt;Thanks! I'm glad to hear they listened to your suggestion. Keep up the good work!&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-7md" rel="alternate"></link><published>2018-03-30T23:00:00+07:00</published><updated>2018-03-30T23:00:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2018-03-30:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-7md</id><content type="html">&lt;p&gt;Yes, I suggested this change, and it got included into MSVC 15.6 =)&lt;/p&gt;
&lt;p&gt;I wrote about it in &lt;a href="/../../posts/addendum-to-performance-comparison-linear-search-vs-binary-search.html"&gt;the addendum&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Rerunning tests is not necessary: the revised results include a pretty good workaround.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: Krishty</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-6md" rel="alternate"></link><published>2018-03-30T17:01:00+07:00</published><updated>2018-03-30T17:01:00+07:00</updated><author><name>Krishty</name></author><id>tag:dirtyhandscoding.github.io,2018-03-30:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-6md</id><content type="html">&lt;p&gt;FYI: Since the recent Visual Studio 15.6 update, Visual C++ has started to emit &lt;code&gt;MOV -1&lt;/code&gt; instead of &lt;code&gt;OR -1&lt;/code&gt; (if compiled for speed).&lt;/p&gt;
&lt;p&gt;Your article must have had some impact. Maybe you want to re-run your tests?&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-5md" rel="alternate"></link><published>2017-09-12T23:04:00+07:00</published><updated>2017-09-12T23:04:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2017-09-12:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-5md</id><summary type="html">&lt;p&gt;What I mean is: "the number returned by this code would be the same no matter how you shuffle the input array". Indeed, it does not necessarily mean that this number would be useful for a non-sorted array.&lt;/p&gt;
&lt;p&gt;In your case the answer would be 2 regardless of the order …&lt;/p&gt;</summary><content type="html">&lt;p&gt;What I mean is: "the number returned by this code would be the same no matter how you shuffle the input array". Indeed, it does not necessarily mean that this number would be useful for a non-sorted array.&lt;/p&gt;
&lt;p&gt;In your case the answer would be 2 regardless of the order of elements.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: A Reader</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-4md" rel="alternate"></link><published>2017-09-12T21:34:00+07:00</published><updated>2017-09-12T21:34:00+07:00</updated><author><name>A Reader</name></author><id>tag:dirtyhandscoding.github.io,2017-09-12:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-4md</id><summary type="html">&lt;p&gt;I have a question about "In fact, this criterion would work the same way even if you shuffle the input array randomly"&lt;/p&gt;
&lt;p&gt;If my array is &lt;code&gt;[10, 2, 1]&lt;/code&gt; and my key is 10, then the number of elements smaller than the key is 2, but this is not the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have a question about "In fact, this criterion would work the same way even if you shuffle the input array randomly"&lt;/p&gt;
&lt;p&gt;If my array is &lt;code&gt;[10, 2, 1]&lt;/code&gt; and my key is 10, then the number of elements smaller than the key is 2, but this is not the index of the key. Am I missing something? The way I see it, is that this counting search requires a sorted array.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Vectorizing std::merge with vpermd from AVX2 and lookup table - Posted by: Morwenn</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-3md" rel="alternate"></link><published>2017-08-27T23:07:00+07:00</published><updated>2017-08-27T23:07:00+07:00</updated><author><name>Morwenn</name></author><id>tag:dirtyhandscoding.github.io,2017-08-27:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/comment-3md</id><summary type="html">&lt;p&gt;In the end, your taken solution goes in the same way, but further, truly solves the problem. At first I was surprised that you didn’t use a binary search to find the greatest element of a collection in the other collection, but your latest post pretty much covers the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the end, your taken solution goes in the same way, but further, truly solves the problem. At first I was surprised that you didn’t use a binary search to find the greatest element of a collection in the other collection, but your latest post pretty much covers the linear vs binary search question.&lt;/p&gt;
&lt;p&gt;I’m surprised that your branchless implementation is faster though, considering that the last time I tried to make a branchless merge, it was terribly slower than branchy version (see SO post). That said, after having read your post, it becomes clearer: the loop condition still depended on the result of the loop, so the branch wasn’t the main issue in the first place. I should try it again.&lt;/p&gt;
&lt;p&gt;Anyway, if you ever write that mergesort article, I’ll be happy to read it ^^&lt;/p&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/q/41129442/1364752"&gt;https://stackoverflow.com/q/41129442/1364752&lt;/a&gt;&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Vectorizing std::merge with vpermd from AVX2 and lookup table - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-2md" rel="alternate"></link><published>2017-08-27T19:38:00+07:00</published><updated>2017-08-27T19:38:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2017-08-27:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/comment-2md</id><summary type="html">&lt;p&gt;I’m glad you liked it!&lt;/p&gt;
&lt;p&gt;Yes, you can merge the first &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements without checking where the pointers are, and then use slower &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt; condition for the rest of the work. For the most likely case of equally-sized arrays, it would cope only with …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I’m glad you liked it!&lt;/p&gt;
&lt;p&gt;Yes, you can merge the first &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements without checking where the pointers are, and then use slower &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt; condition for the rest of the work. For the most likely case of equally-sized arrays, it would cope only with 50% of the issue (regardless of elements order). I guess my perfectionism does not like that =) The things I suggested fix the problem almost completely, except for maybe pathologically ordered inputs.&lt;/p&gt;
&lt;p&gt;Hopefully I'll implement merge sort on top of the suggested merge algorithm, but I'm afraid it won't happen soon =(&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Vectorizing std::merge with vpermd from AVX2 and lookup table - Posted by: Morwenn</title><link href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-1md" rel="alternate"></link><published>2017-08-26T19:29:00+07:00</published><updated>2017-08-26T19:29:00+07:00</updated><author><name>Morwenn</name></author><id>tag:dirtyhandscoding.github.io,2017-08-26:/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html/comment-1md</id><summary type="html">&lt;p&gt;Hi, I found your article very interesting (and being a code-stealer, I might borrow some ideas to improve some of my algorithms). I also tried to improve a simple merge algorithm once or twice, and came up with a few tricks. Condiering how smart some of the ideas you describe …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hi, I found your article very interesting (and being a code-stealer, I might borrow some ideas to improve some of my algorithms). I also tried to improve a simple merge algorithm once or twice, and came up with a few tricks. Condiering how smart some of the ideas you describe are, I’m surprised that you didn’t describe one the simplest tricks I use: since we know the size of the collections, we know that we will have to move at least &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt; elements from each of the original collections, so we can do a blind loop from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;min(aCnt, bCnt)&lt;/code&gt;, then the usual loop that checks for &lt;code&gt;i &amp;lt; aCnt &amp;amp;&amp;amp; j &amp;lt; bCnt&lt;/code&gt;. In order to do that, I actually copy pointers that I increment instead of incrementing the indices, so it's a bit different. I feel that I suck at explaining, so you could just have a look at the code at the end of the algorithm. The trick ensures that the first loop condition is trivial rather than repeatedly checking for the values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; that are unpredictable at every iteration.&lt;/p&gt;
&lt;p&gt;Anyway, that was a great article; really interesting. Kudos! &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97"&gt;https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97&lt;/a&gt;&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: dirtyhandscoding</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-3md" rel="alternate"></link><published>2017-08-26T19:06:00+07:00</published><updated>2017-08-26T19:06:00+07:00</updated><author><name>dirtyhandscoding</name></author><id>tag:dirtyhandscoding.github.io,2017-08-26:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-3md</id><summary type="html">&lt;p&gt;Yes, this is the official way of using IACA under MSVC x64. However, when you use &lt;code&gt;IACA_VC64_START&lt;/code&gt;, you cannot guarantee that the marker would get exactly at the beginning of the loop in assembly (same issue for end marker), compiler can and does move it around freely. Maybe 32-bit case …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Yes, this is the official way of using IACA under MSVC x64. However, when you use &lt;code&gt;IACA_VC64_START&lt;/code&gt;, you cannot guarantee that the marker would get exactly at the beginning of the loop in assembly (same issue for end marker), compiler can and does move it around freely. Maybe 32-bit case also has this problem...&lt;/p&gt;
&lt;p&gt;When you have a small loop and compiler moves marker away, you get quite different analysis. Moreover, sometimes inter-iteration dependencies are completely incorrect because a few first instructions of the loop are missing from the analysed section of assembly.&lt;/p&gt;
&lt;p&gt;I used these macros myself in the past. Now I know reliable way of setting the markers exactly where I want, so I’m done with the macros.&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: optimizedaway</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-2md" rel="alternate"></link><published>2017-08-26T18:16:00+07:00</published><updated>2017-08-26T18:16:00+07:00</updated><author><name>optimizedaway</name></author><id>tag:dirtyhandscoding.github.io,2017-08-26:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-2md</id><content type="html">&lt;p&gt;IACA runs just fine for 64 bit exes, use &lt;code&gt;IACA_VC64_START&lt;/code&gt;, &lt;code&gt;IACA_V64_END&lt;/code&gt; defines and &lt;code&gt;-64&lt;/code&gt; command line arg i.e. &lt;code&gt;iaca -64 -arch HSW MyProgram.exe&lt;/code&gt;&lt;/p&gt;</content><category term="Uncategorized"></category></entry><entry><title>Performance comparison: linear search vs binary search - Posted by: demofox2</title><link href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-1md" rel="alternate"></link><published>2017-08-25T23:44:00+07:00</published><updated>2017-08-25T23:44:00+07:00</updated><author><name>demofox2</name></author><id>tag:dirtyhandscoding.github.io,2017-08-25:/posts/performance-comparison-linear-search-vs-binary-search.html/comment-1md</id><content type="html">&lt;p&gt;Nice analysis. Interesting stuff!&lt;/p&gt;</content><category term="Uncategorized"></category></entry></feed>