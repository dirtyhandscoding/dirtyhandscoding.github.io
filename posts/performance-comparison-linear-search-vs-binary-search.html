<!DOCTYPE html>
<html lang="en">
<head>
        <!-- load favicon from /images -->
        <link rel="icon" type="image/png" href="/images/favicon.png" />
        <!-- stgatilov: properly detect device width on a mobile -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 

        <meta charset="utf-8" />
        <title>Performance comparison: linear search vs binary search</title>
        <link rel="stylesheet" href="https://dirtyhandscoding.github.io/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dirty hands coding Atom Feed" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Dirty hands coding RSS Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://dirtyhandscoding.github.io/">Dirty hands coding </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">ARCHIVES</a></li>
                    <li><a href="/categories.html">CATEGORIES</a></li>
                    <li><a href="/tags.html">TAGS</a></li>
                    <li><a href="/pages/contact.html">CONTACT</a></li>
                </ul>
<form class="navbar-search" action="https://dirtyhandscoding.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);">
                        <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">
                    </form>
                </nav>
<div id="submenu">
                    <ul>
                            <li class="active"><a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/the-dark-mod.html">The Dark Mod</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/uncategorized.html">Uncategorized</a></li>
                    </ul>
                <div>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" rel="bookmark"
           title="Permalink to Performance comparison: linear search vs binary search">Performance comparison: linear search vs binary search</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>25 August 2017</span>
	        <span>| in <a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></span>
<span>| tags: <a href="https://dirtyhandscoding.github.io/tag/binary-search.html">binary search</a><a href="https://dirtyhandscoding.github.io/tag/cmov.html">cmov</a><a href="https://dirtyhandscoding.github.io/tag/iaca.html">iaca</a><a href="https://dirtyhandscoding.github.io/tag/simd.html">simd</a></span>
</footer><!-- /.post-info -->      
      <p>While working on an implementation of merge sort promised in <a href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html">the previous article</a>, I realized that I'd like to use one neat little thing, which is worth its own post. It is a simple strategy for sorting or doing comparison-based tasks, which works wonderfully when input data is small enough.</p>
<p>Suppose that we have a very small array and we want to sort it as fast as possible. Indeed, applying some fancy <em>O(N log N)</em> algorithm is not a good idea: although it has optimal asymptotic performance, its logic is too complicated to outperform simple bubble-sort-like algorithms which take <em>O(N^2)</em> time instead. That's why every well-optimized sorting algorithm based on quicksort (e.g. std::sort) or mergesort includes some simple quadratic algorithm which is run for sufficiently small subarrays like N &lt;= 32.</p>
<p>What exactly should we strive for to get an algorithm efficient for small N? Here is the list of things to look for:
<ol>
  <li>Avoid branches whenever possible: unpredictable ones are very slow.</li>
  <li>Reduce data dependency: this allows to fully utilize processing units in CPU pipeline.</li>
  <li>Prefer simple data access and manipulation patterns: this allows to vectorize the algorithm.</li>
  <li>Avoid complicated algorithms: they almost always fail on one of the previous points, and they sometimes do too much work for small inputs.</li>
</ol></p>
<p>I decided to start investigating a simpler problem first, which is solved by std::lower_bound: <u>given a sorted array of elements and a key, find index of the first array element greater or equal than the key</u>. And this investigation soon developed into a full-length standalone article.</p>


<h2 id="binary-search"><a class="toclink" href="#binary-search">Binary search</a></h2>
<p>The problem is typically solved with binary search in <em>O(log N)</em> time, but it might easily happen so that for small N simple linear algorithm would be faster. Of course, not all implementations of binary search are created equal: for small arrays branchless implementation is preferred. You can read about it for instance in <a href="https://blog.demofox.org/2017/06/20/simd-gpu-friendly-branchless-binary-search/">this demofox's blog post</a>. Here is a branchless implementation that we will use in the comparison later:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">binary_search_branchless</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">intptr_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">intptr_t</span> <span class="n">logstep</span> <span class="o">=</span> <span class="n">bsr</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">intptr_t</span> <span class="n">step</span> <span class="o">=</span> <span class="kt">intptr_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">logstep</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="o">?</span> <span class="n">pos</span> <span class="o">+</span> <span class="nl">step</span> <span class="p">:</span> <span class="n">pos</span><span class="p">);</span>
        <span class="n">step</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This code only works properly when N+1 is power of two.
In order to support arbitrary size of input array, some sort of modification is required. The best approach for it is described in <a href="https://www.pvk.ca/Blog/2012/07/03/binary-search-star-eliminates-star-branch-mispredictions/">this blog post from Paul Khuong</a>, which is: make the very first iteration special by using <code>step = n+1 - 2^logstep</code> instead of just <code>2^logstep</code>, so that regardless of comparison result the next search interval would have length <code>2^logstep</code>, including either the beginning of array or the end of array (note that two such possible intervals overlap, and this is <strong>not</strong> a problem).</p>
<p>The comparison itself is included in the ternary operator, which is supposed to compile into <code>cmovXX</code> instruction. And it really happens (unless your compiler thinks that you compile for 486), according to assembly listing of the innermost loop:</p>
<div class="highlight"><pre><span></span><span class="nl">$LL491@main:</span>
    <span class="nf">lea</span> <span class="no">rax</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rcx</span><span class="err">+</span><span class="no">rdx</span><span class="p">]</span>
    <span class="nf">cmp</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">4</span><span class="p">],</span> <span class="no">r8d</span>
    <span class="nf">cmovl</span> <span class="no">rdx</span><span class="p">,</span> <span class="no">rax</span>
    <span class="nf">sar</span> <span class="no">rcx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">test</span> <span class="no">rcx</span><span class="p">,</span> <span class="no">rcx</span>
    <span class="nf">jg</span> <span class="no">SHORT</span> <span class="no">$LL491@main</span>
</pre></div>


<p>How good is this binary search implementation? It has no branches (point 1 from the above list), which is great. But it is inherently sequental (point 2): you cannot know which element to load on the next step until the element on the current step has been loaded and compared completely. Data access is scalar (point 3): you cannot vectorize it even if several keys are searched simultaneously.</p>
<p>We can take closer look by using <a href="https://software.intel.com/en-us/articles/intel-architecture-code-analyzer">Intel Architecture Code Analyzer</a>: IACA is a small static analysis tool, which analyzes a snippet of code at instruction level. It assumes that the code piece is run in the infinite loop, that all branches are well-predicted and not taken, and that all memory accesses hit L1 cache (plus maybe some other assumptions). It is somewhat tricky to use with Visual C++ 64-bit compiler: you have to copy-paste the piece of code from assembly listing, surround it with markers (which are a bit wrong in iacaMarks.h by the way), then compile it with ml64.exe, and pass the resulting object file into iaca.exe.</p>
<p>Here is what IACA says about the innermost loop:</p>
<div class="highlight"><pre><span></span><span class="n">Throughput</span> <span class="n">Analysis</span> <span class="n">Report</span>
<span class="o">--------------------------</span>
<span class="n">Block</span> <span class="n">Throughput</span><span class="p">:</span> <span class="mf">2.15</span> <span class="n">Cycles</span>       <span class="n">Throughput</span> <span class="n">Bottleneck</span><span class="p">:</span> <span class="n">Dependency</span> <span class="n">chains</span> <span class="p">(</span><span class="n">possibly</span> <span class="n">between</span> <span class="n">iterations</span><span class="p">)</span>

<span class="n">Port</span> <span class="n">Binding</span> <span class="n">In</span> <span class="n">Cycles</span> <span class="n">Per</span> <span class="n">Iteration</span><span class="p">:</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span>  <span class="n">Port</span>  <span class="o">|</span>  <span class="mi">0</span>   <span class="o">-</span>  <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>   <span class="o">|</span>  <span class="mi">2</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">3</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">4</span>   <span class="o">|</span>  <span class="mi">5</span>   <span class="o">|</span>  <span class="mi">6</span>   <span class="o">|</span>  <span class="mi">7</span>   <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span> <span class="n">Cycles</span> <span class="o">|</span> <span class="mf">1.5</span>    <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">0.9</span>  <span class="o">|</span> <span class="mf">0.5</span>    <span class="mf">0.5</span>  <span class="o">|</span> <span class="mf">0.5</span>    <span class="mf">0.5</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">1.1</span>  <span class="o">|</span> <span class="mf">1.5</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>

<span class="o">|</span> <span class="n">Num</span> <span class="n">Of</span> <span class="o">|</span>                    <span class="n">Ports</span> <span class="n">pressure</span> <span class="ow">in</span> <span class="n">cycles</span>                     <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span>  <span class="n">Uops</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">-</span> <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>  <span class="o">|</span>  <span class="mi">2</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">3</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">4</span>  <span class="o">|</span>  <span class="mi">5</span>  <span class="o">|</span>  <span class="mi">6</span>  <span class="o">|</span>  <span class="mi">7</span>  <span class="o">|</span>    <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.3</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rax</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="o">+</span><span class="n">rcx</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span> <span class="mf">0.5</span>   <span class="mf">0.5</span> <span class="o">|</span> <span class="mf">0.5</span>   <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">0.4</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">cmovl</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">0.5</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">sar</span> <span class="n">rcx</span><span class="p">,</span> <span class="mh">0x1</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">0.6</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">test</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">rcx</span>
<span class="o">|</span>   <span class="mi">0</span><span class="n">F</span>   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">jnle</span> <span class="mh">0xffffffffffffffee</span>
<span class="n">Total</span> <span class="n">Num</span> <span class="n">Of</span> <span class="n">Uops</span><span class="p">:</span> <span class="mi">6</span>
</pre></div>


<p>So it says that bottleneck is "dependency chains" and it estimates single iteration of the loop in 2.15 cycles. The estimate is clearly wrong: it is easy to see that the first three instructions must be executed sequentally, and the first of them cannot start before that last of them from the previous iterations has finished. A load from L1 <a href="https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/389767">costs 4 cycles</a> latency-wise, address generation and other three instructions take at least 1 cycle each. So the innermost loop should take 8 cycles per iteration. If we look how performance measurements increase from doubling N, we can estimate one iteration in 4-5 cycles throughput and 10 cycles latency: both are much greater that the estimate given by IACA.</p>
<p>Since the loop in the binary search is very small (4-6 microops) and it goes for tiny number of iterations (e.g. 6 iterations for N = 64), one might suspect that the loop itself can take considerable time. That's why I have also implemented fully unrolled version of branchess binary search:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">intptr_t</span> <span class="n">MAXN</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">binary_search_branchless_UR</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">MAXN</span><span class="p">);</span>
    <span class="kt">intptr_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="cp">#define STEP(logstep) \</span>
<span class="cp">        if ((1&lt;&lt;logstep) &lt; MAXN) \</span>
<span class="cp">            pos = (arr[pos + (1&lt;&lt;logstep)] &lt; key ? pos + (1&lt;&lt;logstep) : pos);</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">STEP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="cp">#undef STEP</span>
    <span class="k">return</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This is of course quite far from the code usable in real programming, but it allows us to ignore all the overhead from the binary search and look directly at its core. IACA provides the following information about the code of the function (N = 64):</p>
<div class="highlight"><pre><span></span><span class="n">Throughput</span> <span class="n">Analysis</span> <span class="n">Report</span>
<span class="o">--------------------------</span>
<span class="n">Block</span> <span class="n">Throughput</span><span class="p">:</span> <span class="mf">29.00</span> <span class="n">Cycles</span>       <span class="n">Throughput</span> <span class="n">Bottleneck</span><span class="p">:</span> <span class="n">Dependency</span> <span class="n">chains</span> <span class="p">(</span><span class="n">possibly</span> <span class="n">between</span> <span class="n">iterations</span><span class="p">)</span>

<span class="n">Port</span> <span class="n">Binding</span> <span class="n">In</span> <span class="n">Cycles</span> <span class="n">Per</span> <span class="n">Iteration</span><span class="p">:</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span>  <span class="n">Port</span>  <span class="o">|</span>  <span class="mi">0</span>   <span class="o">-</span>  <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>   <span class="o">|</span>  <span class="mi">2</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">3</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">4</span>   <span class="o">|</span>  <span class="mi">5</span>   <span class="o">|</span>  <span class="mi">6</span>   <span class="o">|</span>  <span class="mi">7</span>   <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span> <span class="n">Cycles</span> <span class="o">|</span> <span class="mf">5.0</span>    <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">5.0</span>  <span class="o">|</span> <span class="mf">3.0</span>    <span class="mf">3.0</span>  <span class="o">|</span> <span class="mf">3.0</span>    <span class="mf">3.0</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">5.0</span>  <span class="o">|</span> <span class="mf">5.0</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>

<span class="o">|</span> <span class="n">Num</span> <span class="n">Of</span> <span class="o">|</span>                    <span class="n">Ports</span> <span class="n">pressure</span> <span class="ow">in</span> <span class="n">cycles</span>                     <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span>  <span class="n">Uops</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">-</span> <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>  <span class="o">|</span>  <span class="mi">2</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">3</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">4</span>  <span class="o">|</span>  <span class="mi">5</span>  <span class="o">|</span>  <span class="mi">6</span>  <span class="o">|</span>  <span class="mi">7</span>  <span class="o">|</span>    <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------</span>
<span class="o">|</span>   <span class="mi">1</span><span class="o">*</span>   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rcx</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x1f</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="ow">or</span> <span class="n">rcx</span><span class="p">,</span> <span class="mh">0xffffffffffffffff</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="mh">0x7c</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rcx</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x40</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x10</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="n">rdx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x20</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rax</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x10</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x4</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="n">rcx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x2</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">rcx</span>
<span class="o">|</span>   <span class="mi">2</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="nb">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">r9</span><span class="o">+</span><span class="n">rdx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x4</span><span class="p">],</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">lea</span> <span class="n">rax</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdx</span><span class="o">+</span><span class="mh">0x1</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">cmovnl</span> <span class="n">rax</span><span class="p">,</span> <span class="n">rdx</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">inc</span> <span class="n">rax</span>
<span class="n">Total</span> <span class="n">Num</span> <span class="n">Of</span> <span class="n">Uops</span><span class="p">:</span> <span class="mi">27</span>
</pre></div>


<p>It is hard to say how IACA got 29 cycles per search. The critical path is marked properly: groups of cmov and cmp must go sequentally after each other, each group taking 7 cycles latency-wise, so latency of the whole code should be about 42 cycles. In the benchmark, the whole search takes 21 cycles throughput and 59 cycles latency, while doubling N adds 4-5 cycles more throughput and 8-9 cycles more latency. It seems that CPU manages to execute several consecutive searches in parallel thanks to pipelining, that's why throughput time is lower than latency time for branchless binary searches.</p>
<p>I believe this is the best you can get from a binary search.</p>
<h2 id="linear-search"><a class="toclink" href="#linear-search">Linear search</a></h2>
<p>Things start to get more interesting when we try to invent a simple search algorithm working in <em>O(N)</em> time. Because there are actually several ways to do so.
If you look the question <a href="https://stackoverflow.com/questions/2741859/how-fast-can-you-make-linear-search">"How fast can you make linear search?"</a> on stackoverflow, you will see a basic code like this:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">linearX_search_scalar</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">intptr_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Most of the answers for the question are just optimized versions of this algorithm: even if they compare more than one element at a time (with SSE), they still break out when the desired element is found. For instance, the author of the question (Schani) suggests the following code in <a href="https://schani.wordpress.com/2010/04/30/linear-vs-binary-search">his blog post</a>:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">linearX_search_sse</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__m128i</span> <span class="o">*</span><span class="n">in_data</span> <span class="o">=</span> <span class="p">(</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">arr</span><span class="p">;</span>
    <span class="kr">__m128i</span> <span class="n">key4</span> <span class="o">=</span> <span class="n">_mm_set1_epi32</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">intptr_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kr">__m128i</span> <span class="n">cmp0</span> <span class="o">=</span> <span class="n">_mm_cmpgt_epi32</span><span class="p">(</span><span class="n">key4</span><span class="p">,</span> <span class="n">in_data</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]);</span>
        <span class="kr">__m128i</span> <span class="n">cmp1</span> <span class="o">=</span> <span class="n">_mm_cmpgt_epi32</span><span class="p">(</span><span class="n">key4</span><span class="p">,</span> <span class="n">in_data</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="kr">__m128i</span> <span class="n">cmp2</span> <span class="o">=</span> <span class="n">_mm_cmpgt_epi32</span><span class="p">(</span><span class="n">key4</span><span class="p">,</span> <span class="n">in_data</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
        <span class="kr">__m128i</span> <span class="n">cmp3</span> <span class="o">=</span> <span class="n">_mm_cmpgt_epi32</span><span class="p">(</span><span class="n">key4</span><span class="p">,</span> <span class="n">in_data</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]);</span>
        <span class="kr">__m128i</span> <span class="n">pack01</span> <span class="o">=</span> <span class="n">_mm_packs_epi32</span><span class="p">(</span><span class="n">cmp0</span><span class="p">,</span> <span class="n">cmp1</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">pack23</span> <span class="o">=</span> <span class="n">_mm_packs_epi32</span><span class="p">(</span><span class="n">cmp2</span><span class="p">,</span> <span class="n">cmp3</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">pack0123</span> <span class="o">=</span> <span class="n">_mm_packs_epi16</span> <span class="p">(</span><span class="n">pack01</span><span class="p">,</span> <span class="n">pack23</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_mm_movemask_epi8</span> <span class="p">(</span><span class="n">pack0123</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">bsf</span><span class="p">(</span><span class="o">~</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This code has no issues from the list of things that may slow down the algorithm, except for one mispredicted branch. The branch which checks if the answer is found is never taken except for the very last iteration when the loop terminates (which may happen at random moment). Of course, single misprediction is not a problem in a long loop, but it may cause problems when we want to optimize a tiny loop. In fact, <a href="https://www.pvk.ca/Blog/2012/07/03/binary-search-star-eliminates-star-branch-mispredictions">Paul Khuong's blog post</a> claims that linear search is always slower than branchless binary search because of this single mispredicted branch. Luckily, there is a way to avoid branches completely.</p>
<p>The idea is very simple: the sought-for index is precisely the number of elements in the array which are less than the key you search for. In fact, this criterion would work the same way even if you shuffle the input array randomly =) Here is the scalar implementation based on this criterion:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">linear_search_scalar</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>For a vectorized implementation, we can compare a pack of four elements with the key, and then subtract the resulting masks (recall that they are -1 when comparison result is true) from the common accumulator. At the end we have to compute horizontal sum of the accumulator to get the total count. Finally, it is better to process several packs during single iteration (similar to unrolling) to reduce loop overhead. Here is the code:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">linear_search_sse</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__m128i</span> <span class="n">vkey</span> <span class="o">=</span> <span class="n">_mm_set1_epi32</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="kr">__m128i</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">__m128i</span> <span class="n">mask0</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]),</span> <span class="n">vkey</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">mask1</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]),</span> <span class="n">vkey</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">]),</span> <span class="n">vkey</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">mask3</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">12</span><span class="p">]),</span> <span class="n">vkey</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">mask0</span><span class="p">,</span> <span class="n">mask1</span><span class="p">),</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">mask3</span><span class="p">));</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
    <span class="k">return</span> <span class="n">_mm_cvtsi128_si32</span><span class="p">(</span><span class="n">cnt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>It requires the input array to be padded with sentinel elements INT_MAX until its size becomes divisible by 16. This requirement may be lifted by processing  at most 15 last elements with additional loop(s), but I suppose such a version would work somewhat slower than the version with sentinels.</p>
<p>IACA provides the following info for the innermost loop of the code:</p>
<div class="highlight"><pre><span></span><span class="n">Throughput</span> <span class="n">Analysis</span> <span class="n">Report</span>
<span class="o">--------------------------</span>
<span class="n">Block</span> <span class="n">Throughput</span><span class="p">:</span> <span class="mf">5.05</span> <span class="n">Cycles</span>       <span class="n">Throughput</span> <span class="n">Bottleneck</span><span class="p">:</span> <span class="n">Dependency</span> <span class="n">chains</span> <span class="p">(</span><span class="n">possibly</span> <span class="n">between</span> <span class="n">iterations</span><span class="p">)</span>

<span class="n">Port</span> <span class="n">Binding</span> <span class="n">In</span> <span class="n">Cycles</span> <span class="n">Per</span> <span class="n">Iteration</span><span class="p">:</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span>  <span class="n">Port</span>  <span class="o">|</span>  <span class="mi">0</span>   <span class="o">-</span>  <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>   <span class="o">|</span>  <span class="mi">2</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">3</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">4</span>   <span class="o">|</span>  <span class="mi">5</span>   <span class="o">|</span>  <span class="mi">6</span>   <span class="o">|</span>  <span class="mi">7</span>   <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span> <span class="n">Cycles</span> <span class="o">|</span> <span class="mf">0.5</span>    <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">4.5</span>  <span class="o">|</span> <span class="mf">2.0</span>    <span class="mf">2.0</span>  <span class="o">|</span> <span class="mf">2.0</span>    <span class="mf">2.0</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">4.5</span>  <span class="o">|</span> <span class="mf">0.5</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>

<span class="o">|</span> <span class="n">Num</span> <span class="n">Of</span> <span class="o">|</span>                    <span class="n">Ports</span> <span class="n">pressure</span> <span class="ow">in</span> <span class="n">cycles</span>                     <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span>  <span class="n">Uops</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">-</span> <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>  <span class="o">|</span>  <span class="mi">2</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">3</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">4</span>  <span class="o">|</span>  <span class="mi">5</span>  <span class="o">|</span>  <span class="mi">6</span>  <span class="o">|</span>  <span class="mi">7</span>  <span class="o">|</span>    <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">-</span><span class="mh">0x20</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">-</span><span class="mh">0x10</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">lea</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x40</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">-</span><span class="mh">0x30</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">-</span><span class="mh">0x40</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpsubd</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">0.5</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">sub</span> <span class="n">rdx</span><span class="p">,</span> <span class="mh">0x1</span>
<span class="o">|</span>   <span class="mi">0</span><span class="n">F</span>   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">jnz</span> <span class="mh">0xffffffffffffffd4</span>
<span class="n">Total</span> <span class="n">Num</span> <span class="n">Of</span> <span class="n">Uops</span><span class="p">:</span> <span class="mi">14</span>
</pre></div>


<p>And again: I'm not sure how IACA got 5.05 cycles per iteration. Most of the work done each iteration is clearly independent between iterations, so in a theoretical infinite loop several consecutive iterations can be executed in parallel, thus hiding latency of memory loads and dependencies. As for performance measurements, going from 64 elements to 128 elements increases time by 12.4 ns, which is 6.2 cycles per iteration. The cost per iteration decreases to 5.5 cycles for larger N. Note that both latency and throughput measurements increase equally with increase of N, which confirms the fact that iterations are processed independently. Given that execution ports pressure is 4.5 cycles per iteration, spending 5.5 cycles is pretty efficient usage of hardware (compared to binary search).</p>
<p>To make sure loop overhead is not critical, I have also implemented fully unrolled version of this vectorized implementation. For N = 64 it has four iterations unrolled, and here is its assembly code analyzed by IACA:</p>
<div class="highlight"><pre><span></span><span class="n">Throughput</span> <span class="n">Analysis</span> <span class="n">Report</span>
<span class="o">--------------------------</span>
<span class="n">Block</span> <span class="n">Throughput</span><span class="p">:</span> <span class="mf">19.25</span> <span class="n">Cycles</span>       <span class="n">Throughput</span> <span class="n">Bottleneck</span><span class="p">:</span> <span class="n">FrontEnd</span><span class="p">,</span> <span class="n">Port1</span><span class="p">,</span> <span class="n">Port5</span>

<span class="n">Port</span> <span class="n">Binding</span> <span class="n">In</span> <span class="n">Cycles</span> <span class="n">Per</span> <span class="n">Iteration</span><span class="p">:</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span>  <span class="n">Port</span>  <span class="o">|</span>  <span class="mi">0</span>   <span class="o">-</span>  <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>   <span class="o">|</span>  <span class="mi">2</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">3</span>   <span class="o">-</span>  <span class="n">D</span>   <span class="o">|</span>  <span class="mi">4</span>   <span class="o">|</span>  <span class="mi">5</span>   <span class="o">|</span>  <span class="mi">6</span>   <span class="o">|</span>  <span class="mi">7</span>   <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="o">|</span> <span class="n">Cycles</span> <span class="o">|</span> <span class="mf">1.0</span>    <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">18.8</span> <span class="o">|</span> <span class="mf">8.0</span>    <span class="mf">8.0</span>  <span class="o">|</span> <span class="mf">8.0</span>    <span class="mf">8.0</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">19.3</span> <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span> <span class="mf">0.0</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------------</span>

<span class="o">|</span> <span class="n">Num</span> <span class="n">Of</span> <span class="o">|</span>                    <span class="n">Ports</span> <span class="n">pressure</span> <span class="ow">in</span> <span class="n">cycles</span>                     <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span>  <span class="n">Uops</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">-</span> <span class="n">DV</span>  <span class="o">|</span>  <span class="mi">1</span>  <span class="o">|</span>  <span class="mi">2</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">3</span>  <span class="o">-</span>  <span class="n">D</span>  <span class="o">|</span>  <span class="mi">4</span>  <span class="o">|</span>  <span class="mi">5</span>  <span class="o">|</span>  <span class="mi">6</span>  <span class="o">|</span>  <span class="mi">7</span>  <span class="o">|</span>    <span class="o">|</span>
<span class="o">---------------------------------------------------------------------------------</span>
<span class="o">|</span>   <span class="mi">1</span><span class="o">*</span>   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">vpxor</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm3</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vmovd</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">r8d</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpbroadcastd</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmm5</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.9</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.1</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x30</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.8</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.3</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x20</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.5</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x10</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x60</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x70</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpsubd</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x40</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x50</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xa0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xb0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpsubd</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x80</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x90</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xe0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xf0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpsubd</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xc0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">2</span><span class="o">^</span>   <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span>   <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpcmpgtd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm5</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0xd0</span><span class="p">]</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm1</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">0.6</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">0.4</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpsubd</span> <span class="n">xmm3</span><span class="p">,</span> <span class="n">xmm4</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpshufd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm3</span><span class="p">,</span> <span class="mh">0x4e</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm2</span><span class="p">,</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm3</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpshufd</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm2</span><span class="p">,</span> <span class="mh">0xb1</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span>           <span class="o">|</span> <span class="mf">1.0</span> <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span> <span class="n">CP</span> <span class="o">|</span> <span class="n">vpaddd</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">xmm2</span>
<span class="o">|</span>   <span class="mi">1</span>    <span class="o">|</span> <span class="mf">1.0</span>       <span class="o">|</span>     <span class="o">|</span>           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span> <span class="n">vmovd</span> <span class="n">eax</span><span class="p">,</span> <span class="n">xmm0</span>
<span class="n">Total</span> <span class="n">Num</span> <span class="n">Of</span> <span class="n">Uops</span><span class="p">:</span> <span class="mi">56</span>
</pre></div>


<p>The broadwell execution ports 1 and 5 are fully saturated here, the beginning and the ending of the function take about 3 cycles throughput, so there is about 16 cycles spent on the middle part, which gives about 4 cycles per loop iteration (i.e. per 16 elements). Performance measurements fully confirm this estimate: going from 64 to 128 elements increases time by 8.3 ns, which is 4.15 cycles per iteration. For larger N, cost per loop iteration perfectly converges to 4 cycles. These statements are true both for throughput and latency performance.</p>
<p>Finally, I have implemented AVX versions of the same algorithm (both in a loop and fully unrolled). They would also be present in comparison.</p>
<h2 id="comparison"><a class="toclink" href="#comparison">Comparison</a></h2>
<p>The testing code works as follows. Both keys and input elements are generated randomly and uniformly between 0 and N+1. The input array always has size N in form 2^k-1, not including one sentinel element INT_MAX. Several input arrays and several keys for search are generated before performance measurement. The search function is called in a loop (without inlining), different input array and key from the pre-generated sets are chosen on each iteration. The cumulative sum of all the answers is printed to console to make sure nothing is thrown away by optimizer. Here is the main loop:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">TRIES</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span> <span class="o">/</span> <span class="n">SIZE</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">TRIES</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">DARR</span> <span class="o">+</span> <span class="p">(</span><span class="n">MEASURE_LATENCY</span> <span class="o">?</span> <span class="n">check</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">DKEY</span> <span class="o">+</span> <span class="p">(</span><span class="n">MEASURE_LATENCY</span> <span class="o">?</span> <span class="n">check</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">i</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">ARR_SAMPLES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">j</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">KEY_SAMPLES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">search_function</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">check</span> <span class="o">+=</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%8.1lf ns : %40s   (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">1e+9</span> <span class="o">*</span> <span class="n">elapsed</span> <span class="o">/</span> <span class="n">TRIES</span><span class="p">,</span> <span class="n">search_name</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
</pre></div>


<p>Originally I wanted to measure only throughput performance, but after having compared the results of MSVC and GCC compilers I realized that I need a mode to measure latency performance too, which is achieved by making input array and key indices dependent on the result of the previous search.
The constants ARR_SAMPLES and KEY_SAMPLES are chosen in such a way that the total size of all pre-generated input arrays is equal to the total size of all pre-generated search keys.</p>
<p>There are several reasons for using such a testing environment. First of all, I don't want to include random number generation into performance measurement, that's why input data is generated beforehand. Secondly, I want to avoid branch predictor memorizing the course of execution completely, that's why there are many input arrays and many keys, which are rotated in the loop. It is important that the number of pre-generated keys is large enough. Lastly, I want to be able to emulate reading from prescribed cache level (L1D, L2), and this is approximated by setting the total size of all pre-generated input data appropriately. Unless said otherwise, all the results and plots are given for the fastest L1D cache: input data takes 64 KB of memory, of which input arrays take 32 KB and fit into cache precisely.</p>
<p>All the measurements were done on Intel Core i3-5005U CPU (Broadwell, 2 GHz, no turbo boost). The code was compiled using VC++2017 x64 compiler with /O2 and /arch:AVX2 (unless noted otherwise).
For all the plots below, the points on plot lines for binary search implementations have cross-like style, while the points for linear search implementations are marked with bold filled shapes. The plot lines are also grouped by color into: black = branching binary search, blue = branchless binary search, yellow = linear search with break, red/magenta = counting linear search (SSE/AVX).</p>
<p>Here are the names of search implementations:
<ul>
  <li><code>binary_search_std</code>: direct call to std::lower_bound</li>
  <li><code>binary_search_simple</code>: basic binary search with branches</li>
  <li><code>binary_search_branchless</code>: branchless binary search</li>
  <li><code>binary_search_branchless_UR</code>: branchless binary search - fully unrolled</li>
  <li><code>linearX_search_sse</code>: linear search with break (SSE)</li>
  <li><code>linear_search_sse</code>: counting linear search (SSE)</li>
  <li><code>linear_search_sse_UR</code>: counting linear search (SSE) - fully unrolled</li>
  <li><code>linear_search_avx</code>: counting linear search (AVX)</li>
  <li><code>linear_search_avx_UR</code>: counting linear search (AVX) - fully unrolled</li>
</ul></p>
<h3 id="initial-attempt"><a class="toclink" href="#initial-attempt">Initial attempt</a></h3>
<p>Here is the plot I got initially with results of throughput performance measurement:
<img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_search_65536_thr_init.png" class="centered w600" /></p>
<p>I spent considerable effort analyzing this plot and making conclusions out of it. I wrote a page of text about it =)
Of course, I did notice how much performance differs for unrolled and looped versions of branchless binary search. But after looking into assembly output, I did not try to further investigate it. And then I tried to compile the code with GCC (just in case), which changed everything...</p>
<p>With TDM GCC 5.1 x64, I got significantly different throughput performance for several search implementations. Linear searches work more or less in the same time (GCC being slightly slower), but the binary searches are tremendously different:
<ol>
<li><code>binary_search_std</code> improved from 60 ns to 47 ns</li>
<li><code>binary_search_simple</code> improved from 49 ns to 16 ns</li>
<li><code>binary_search_branchless</code> improved 25 ns to 11 ns</li>
<li><code>binary_search_branchless_UR</code> worsened from 8 to 26 ns</li>
</ol></p>
<p>The point 1 is explained by different implementations of STL. The points 2 and 4 are caused by differences in <code>cmovXX</code> instructions generation: <code>binary_search_simple</code> uses cmov on GCC instead of branches (quite unexpectedly: branches were intended), and the assembly code of <code>binary_search_branchless_UR</code> is some terrible mess on GCC, including both cmov-s and branches mixed (that's really bad of GCC). The point 3 cannot be explained so easily: assembly outputs are very similar, and cmov-s are used in both of them.</p>
<p>After having spent some time on blending one assembly code into the other one, I found the critical instruction which spoils everything for MSVC-generated assembly code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="err">?</span><span class="nf">binary_search_branchless@@YAHPEBHHH@Z</span> <span class="no">PROC</span>
<span class="nf">bsr</span> <span class="no">edx</span><span class="p">,</span> <span class="no">edx</span>         <span class="c">; intptr_t logstep = bsr(n);</span>
<span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="hll"><span class="nf">or</span> <span class="no">r9</span><span class="p">,</span> <span class="p">-</span><span class="mi">1</span>            <span class="c">; intptr_t pos = -1;</span>
</span><span class="nf">shlx</span> <span class="no">rax</span><span class="p">,</span> <span class="no">rax</span><span class="p">,</span> <span class="no">rdx</span>   <span class="c">; intptr_t step = intptr_t(1) &lt;&lt; logstep;</span>

<span class="nf">test</span> <span class="no">rax</span><span class="p">,</span> <span class="no">rax</span>        <span class="c">; while (step &gt; 0) {</span>
<span class="nf">jle</span> <span class="no">SHORT</span> <span class="no">$LN13</span>
<span class="nf">npad</span> <span class="mi">10</span>
<span class="nl">$LL2:</span>
    <span class="c">; pos = (arr[pos + step] &lt; key ? pos + step : pos);</span>
    <span class="c">; step &gt;&gt;= 1;</span>

    <span class="nf">lea</span> <span class="no">rdx</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rax</span><span class="err">+</span><span class="no">r9</span><span class="p">]</span>
    <span class="nf">sar</span> <span class="no">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">cmp</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rcx</span><span class="err">+</span><span class="no">rdx</span><span class="p">*</span><span class="mi">4</span><span class="p">],</span> <span class="no">r8d</span>
<span class="hll">    <span class="nf">cmovge</span> <span class="no">rdx</span><span class="p">,</span> <span class="no">r9</span>
</span>    <span class="nf">mov</span> <span class="no">r9</span><span class="p">,</span> <span class="no">rdx</span>
    <span class="nf">test</span> <span class="no">rax</span><span class="p">,</span> <span class="no">rax</span>
<span class="nf">jg</span> <span class="no">SHORT</span> <span class="no">$LL2</span>

<span class="nf">lea</span> <span class="no">rax</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdx</span><span class="err">+</span><span class="mi">1</span><span class="p">]</span>   <span class="c">; return pos + 1;</span>
<span class="nf">ret</span> <span class="mi">0</span>
<span class="nl">$LN13:</span>
<span class="nf">lea</span> <span class="no">rax</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">r9</span><span class="err">+</span><span class="mi">1</span><span class="p">]</span>      <span class="c">; return pos + 1;</span>
<span class="nf">ret</span> <span class="mi">0</span>
<span class="err">?</span><span class="nf">binary_search_branchless@@YAHPEBHHH@Z</span> <span class="no">ENDP</span>
</pre></div>
</td></tr></table>

<p>The instruction "or r9, -1" on 4-th line is a cunning way of putting -1 into register: it takes only 4 bytes of machine code, while the obvious "mov r9, -1" takes 7 bytes of machine code. It is very similar to the "xor eax, eax" hack for zeroing a register, which every CPU understands today and <a href="https://stackoverflow.com/a/18027854/556899">handles during register renaming</a>. Unfortunately, there is no special handling of instruction "or r9, -1" in Broadwell or other x86 architectures, so false dependency is created: CPU assumes that the new value of r9 register depends on its previous value, which is not set before that in the function. Since the function is called over and over again, most likely the previous value is assigned in line 17 of the previous function call, and it is set to the answer of search. As a result, CPU cannot start executing the next search without knowing the result of the previous one, hence latency is actually measured on MSVC instead of throughput.</p>
<p>This explains why MSVC version is so much slower than that of GCC. If we look into latency measurements (provided below), we'll see the values for <code>binary_search_branchless</code> there equal to those on the plot above.
The issue can be circumvented by assigning value -1 from non-const global variable, then MSVC has to load it from memory (hopefully from L1D) with mov instruction:</p>
<div class="highlight"><pre><span></span><span class="kt">intptr_t</span> <span class="n">MINUS_ONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">binary_search_branchless</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//intptr_t pos = -1;            //generates &quot;or r9, -1&quot; on MSVC -- false dependency harms throughput</span>
    <span class="kt">intptr_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">MINUS_ONE</span><span class="p">;</span>       <span class="c1">//workaround for MSVC: generates mov without dependency</span>
</pre></div>


<h3 id="revised-code"><a class="toclink" href="#revised-code">Revised code</a></h3>
<p>After I resolved the issue with MSVC code gen, I decided that I should measure both throughput and latency time. Here are the results for revised code (throughput and latency performance):</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_search_65536_thr.png" class="w550" />
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_search_65536_lat.png" class="w550" />
</div>

<p>Here are some facts about the results:
<ol>
<li>For a binary search, branchless implementation is much faster than branching one: almost four times faster in throughput sense and two times faster by latency. I think it would remain so even if support for non-power-of-two array lengths was added to branchless implementation.</li>
<li>Full unrolling of branchless binary search (with exactly known number of comparisons to do) makes search faster by about 30% in throughput sense. The difference in latency is negligible: 3-4 cycles.</li>
<li>It is hard to ensure that binary search written in C++ is branchless on every platform, every compiler and every set of settings. I realized this after looking at GCC's work: it managed to miracously emit cmov in once case and stupidly screw cmov-s in the other place. Also, MSVC screws the last cmov in <code>binary_search_branchless_UR</code> if it is inlined into the benchmark code. There is no way to get cmov-s reliably except for using assembly.</li>
<li>Latency time of branchless binary search is twice as large as throughput time. I suppose it means that CPU runs two searches in parallel when they are independent. However, it can be harder to ensure such independence in real workflow, when binary search is not the only computation done in the hot loop.</li>
<li>Counting linear search is faster than linear search with break for small N. This is because linear search with break executes unpredictable branch (which does not happen for N = 16 because it always needs one iteration). There is about 60% improvement in throughput for N = 32, and about 35% improvement for N = 64 (less improvement in latency). It seems that the branch costs about 10 cycles in both throughput and latency.</li>
<li>The linear search with break becomes faster than counting linear search shortly after N = 128. For N = 1024 it is 80% faster, and I guess the performance ratio should converge to two at infinity. This happens because linear search with break processes only half of input array on average, while counting linear search always goes through the whole array. It is questionable whether it is a huge benefit, given that for N &gt; 128 branchless binary search is faster and reads substantially less data anyway.</li>
<li>For counting linear search, AVX version is noticeably faster only for N = 64, and for larger N it is about 50% faster. Perhaps more efficient AVX implementation would achieve better ratio. As for full unrolling, it gives another almost 50% boost for large N (like N = 256 or more), althrough for small N its benefit is again much less noticeable.</li>
<li>As for binary vs linear search competition, the situation is different for throughput and latency. For throughput performance, branchless binary search is slower for N &lt; 64 (by at most 30%) and faster for N &gt; 64, although the fully unrolled version of it is as fast as SSE linear search even for N = 16 and N = 32. For latency performance, branchless binary search catches up with SSE linear search only for N between 128 and 256 (double that for AVX), and it is slower by up to 50% for N = 32 and N = 64.</li>
</ol></p>
<h3 id="additional-plots"><a class="toclink" href="#additional-plots">Additional plots</a></h3>
<p>We can also estimate how much time per element is required for each search. Here are the plot where elapsed time is reported per array element (recall that you have to multiply by two to convert from ns to cycles):</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_elem_65536_thr.png" class="w550" />
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_elem_65536_lat.png" class="w550" />
</div>

<p>Notice how all the lines are converging to each other on the left: for N = 16 all searches have very similar performance. I think this is the overhead of benchmarking environment which makes them so similar: I simply cannot see e.g. how much faster AVX version is (compared to SSE version) with my crude measuring tool. The linear searches are very compact, for instance unrolled SSE version for N = 16 executes only 16 instructions without any branches at all.</p>
<p>And here is yet another view of the results where time per search is divided by the logarithm of N (i.e. by the number of comparisons in binary search). It shows the constant in <em>O(log N)</em> estimate for binary searches, just like the previous plot shows constant in <em>O(N)</em> estimate for linear searches.
These images can be helpful to estimate the cost of single step of a binary search.</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_log_65536_thr.png" class="w550" />
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_log_65536_lat.png" class="w550" />
</div>

<p>Finally, below are plots recorded while using 512KB of input data, which tries to simulate L2 memory access. The CPU has 256 KB of L2 cache per core, which means that all input arrays fit into it perfectly. It seems that adding L1 cache misses into benchmark makes things closer to each other, but does not change the situation much.</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_search_524288_thr.png" class="w550" />
    <img src="https://dirtyhandscoding.github.io/images/2_lin_bin_search/plot_search_524288_lat.png" class="w550" />
</div>

<p>Note that not all memory loads are forced to access L2 cache, sometimes faster L1 cache is also used. If you consider counting linear search, it always accesses all the array elements during search. Because of that the whole 256 KB of input array data is accessed over and over again, which makes sure that it is read from L2 cache. In case of binary search, different elements have different probability of being accessed: for N = 1023, 511-st element is always accessed, elements 255 and 767 are accessed with probability 50%, even-indexed elements have probability 0.2% of being accessed (see more about it in <a href="http://bannalia.blogspot.ru/2015/06/cache-friendly-binary-search.html">this bannalia blog post</a>) So it is quite likely that the most popular elements get into smaller L1 cache, accelerating several first comparisons in the search. For instance, for N = 512 there are 128 input arrays and 32 KB of L1D cache, so each input array gets 4 cache lines in L1D, enough to accelerate first two iterations. This is a natural benefit of binary search, which works in real world too.</p>
<h2 id="the-code"><a class="toclink" href="#the-code">The code</a></h2>
<p>All the code and materials are available in GitHub repository <a href="https://github.com/stgatilov/linear-vs-binary-search">linear-vs-binary-search</a>.</p>
<h2 id="conclusion"><a class="toclink" href="#conclusion">Conclusion</a></h2>
<p>The proposed "counting" linear search is noticeably faster for small array lengths than linear search with break, because branch misprediction is removed from it. So it makes sense to always use counting version of linear search instead of the breaking one, since for larger array lengths binary search becomes faster anyway.</p>
<p>Binary search is surprisingly good to stand against linear search, given that it fully utilizes conditional move instructions instead of branches. In my opinion, there is no reason to prefer linear search over binary search, better make sure that your compiler does not generate branches for the binary search. Counting linear search is worth using only in a rare case when it is known that array length is very small and the search performance is really critically important. Also, the idea of counting linear search is easy to embed into some vectorized computation, unlike the binary search.</p>
<hr/>

<h2 id="addendum"><a class="toclink" href="#addendum">Addendum</a></h2>
<p>I decided to keep all the additional information about this article in a separate blog post. You may find more information in <a href="https://dirtyhandscoding.github.io/posts/addendum-to-performance-comparison-linear-search-vs-binary-search.html">the addendum</a>, including some more implementations and extended performance comparison.</p>
<h2 id="reddit"><a class="toclink" href="#reddit">Reddit</a></h2>
<p>This article is discussed on reddit <a href="https://www.reddit.com/r/programming/comments/6w103l/performance_comparison_linear_search_vs_binary/">here</a>.</p>
      
    </div><!-- /.entry-content -->
    <section>
        <div id="post-share-links" class="inline-menu">
            <div>Share on:</div>
            <a href="https://twitter.com/intent/tweet?text=Performance%20comparison%3A%20linear%20search%20vs%20binary%20search&url=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share on Twitter">Twitter</a><!--
            --><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share on Facebook">Facebook</a><!--
            --><a href="https://plus.google.com/share?url=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share on Google Plus">Google+</a><!--
            --><a href="https://sharetodiaspora.github.io/?title=Performance%20comparison%3A%20linear%20search%20vs%20binary%20search&url=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share on Diaspora">Diaspora*</a><!--
            --><a href="https://news.ycombinator.com/submitlink?t=Performance%20comparison%3A%20linear%20search%20vs%20binary%20search&u=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share on HackerNews">HackerNews</a><!--
            --><a href="mailto:?subject=Performance%20comparison%3A%20linear%20search%20vs%20binary%20search&amp;body=https%3A//dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html" target="_blank" class="icon-label" title="Share via Email">Email</a>
        </div>
    </section>
    
    			<!--<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.4.min.js"></script>-->
		<script src="https://dirtyhandscoding.github.io/theme/js/jquery.min.js"></script>
	<script type="text/javascript" src="https://dirtyhandscoding.github.io/theme/pelican_comment_system/comments.js"></script>
	<script type="text/javascript">
		$(document).ready(function() {
			CommentSystem.email_user   = "itiswrongemail";
			CommentSystem.email_domain = "outlook.com";

			$('#pcs-comment-form').on("submit",
				function( event )
				{
					event.preventDefault();
					$(location).attr('href', CommentSystem.getMailtoLink("performance-comparison-linear-search-vs-binary-search"));
				}
			);
		});
	</script>

    	<section>
	<div id="pcs-comments-header" class="inline-menu">
	<header>
		<div>Comments (10)</div>
		<button type="button" title="Expand or collapse the comments section" class="icon-label" id="pcs-comments-collapse-button" onclick="CommentSystem.collapsible($('#pcs-comments'), $(this));">
			<span class="nocss">expand</span>
		</button>
			<a href="https://dirtyhandscoding.github.io/feeds/comment.performance-comparison-linear-search-vs-binary-search.atom.xml" class="icon-label">atom feed: comments</a>
	</header>
	</div>
	<div id="pcs-comments">
		<ul>
			<li id="comment-1md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\6801a6ac794c06e23d3ffeb1d983ecf5.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-1md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('1md', 'demofox2');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							demofox2
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-25T23:44:00+07:00" title="2017-08-25T23:44:00+07:00">(25.08.2017 at 23:44)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>Nice analysis. Interesting stuff!</p>
					</div>
					</div>
				</div>
			</li>
			<li id="comment-2md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\6659b682f43a717b86b6520dbdaee042.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-2md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('2md', 'optimizedaway');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							optimizedaway
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-26T18:16:00+07:00" title="2017-08-26T18:16:00+07:00">(26.08.2017 at 18:16)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>IACA runs just fine for 64 bit exes, use <code>IACA_VC64_START</code>, <code>IACA_V64_END</code> defines and <code>-64</code> command line arg i.e. <code>iaca -64 -arch HSW MyProgram.exe</code></p>
					</div>
					</div>
				</div>
			</li>
			<li id="comment-3md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\f34da67b9f39c15787aa7a9e932509bc.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-3md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('3md', 'dirtyhandscoding');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							dirtyhandscoding
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-26T19:06:00+07:00" title="2017-08-26T19:06:00+07:00">(26.08.2017 at 19:06)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>Yes, this is the official way of using IACA under MSVC x64. However, when you use <code>IACA_VC64_START</code>, you cannot guarantee that the marker would get exactly at the beginning of the loop in assembly (same issue for end marker), compiler can and does move it around freely. Maybe 32-bit case also has this problem...</p>
<p>When you have a small loop and compiler moves marker away, you get quite different analysis. Moreover, sometimes inter-iteration dependencies are completely incorrect because a few first instructions of the loop are missing from the analysed section of assembly.</p>
<p>I used these macros myself in the past. Now I know reliable way of setting the markers exactly where I want, so I’m done with the macros.</p>
					</div>
					</div>
				</div>
			</li>
			<li id="comment-4md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\8032ed702bece6db90085e4f9cbf0cf2.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-4md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('4md', 'A%20Reader');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							A Reader
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-09-12T21:34:00+07:00" title="2017-09-12T21:34:00+07:00">(12.09.2017 at 21:34)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>I have a question about "In fact, this criterion would work the same way even if you shuffle the input array randomly"</p>
<p>If my array is <code>[10, 2, 1]</code> and my key is 10, then the number of elements smaller than the key is 2, but this is not the index of the key. Am I missing something? The way I see it, is that this counting search requires a sorted array.</p>
					</div>
					</div>
						<!--<hr>-->
						<ul>
										<li id="comment-5md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\f34da67b9f39c15787aa7a9e932509bc.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-5md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('5md', 'dirtyhandscoding');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							dirtyhandscoding
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-09-12T23:04:00+07:00" title="2017-09-12T23:04:00+07:00">(12.09.2017 at 23:04)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>What I mean is: "the number returned by this code would be the same no matter how you shuffle the input array". Indeed, it does not necessarily mean that this number would be useful for a non-sorted array.</p>
<p>In your case the answer would be 2 regardless of the order of elements.</p>
					</div>
					</div>
				</div>
			</li>

						</ul>
				</div>
			</li>
			<li id="comment-6md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\282e4c5ff151d0ca5b0e4818c07b65c6.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-6md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('6md', 'Krishty');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							Krishty
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2018-03-30T17:01:00+07:00" title="2018-03-30T17:01:00+07:00">(30.03.2018 at 17:01)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>FYI: Since the recent Visual Studio 15.6 update, Visual C++ has started to emit <code>MOV -1</code> instead of <code>OR -1</code> (if compiled for speed).</p>
<p>Your article must have had some impact. Maybe you want to re-run your tests?</p>
					</div>
					</div>
						<!--<hr>-->
						<ul>
										<li id="comment-7md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\f34da67b9f39c15787aa7a9e932509bc.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-7md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('7md', 'dirtyhandscoding');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							dirtyhandscoding
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2018-03-30T23:00:00+07:00" title="2018-03-30T23:00:00+07:00">(30.03.2018 at 23:00)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>Yes, I suggested this change, and it got included into MSVC 15.6 =)</p>
<p>I wrote about it in <a href="/../../posts/addendum-to-performance-comparison-linear-search-vs-binary-search.html">the addendum</a>.</p>
<p>Rerunning tests is not necessary: the revised results include a pretty good workaround.</p>
					</div>
					</div>
						<!--<hr>-->
						<ul>
										<li id="comment-8md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\282e4c5ff151d0ca5b0e4818c07b65c6.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-8md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('8md', 'Krishty');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							Krishty
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2018-04-01T02:35:00+07:00" title="2018-04-01T02:35:00+07:00">(01.04.2018 at 02:35)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>Thanks! I'm glad to hear they listened to your suggestion. Keep up the good work!</p>
					</div>
					</div>
				</div>
			</li>

						</ul>
				</div>
			</li>

						</ul>
				</div>
			</li>
			<li id="comment-9md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\9f2bb4b170a38d5cf4df884ee600a76c.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-9md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('9md', 'Dr.%20Khalid%20Omar%20Thabit');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							Dr. Khalid Omar Thabit
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2018-11-14T06:23:00+07:00" title="2018-11-14T06:23:00+07:00">(14.11.2018 at 06:23)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>If prefetch instruction was used with the AVX2 in linear search it would even improve the speed.</p>
					</div>
					</div>
				</div>
			</li>
			<li id="comment-10md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\8564164a5c4ae9210f39cc4b256743d6.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html#comment-10md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('10md', 'RyanB');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							RyanB
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2019-05-15T10:06:00+07:00" title="2019-05-15T10:06:00+07:00">(15.05.2019 at 10:06)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>I came up with a little trick that seems to be 33% faster on my machine, for my use case (and it doesn’t require sorting):
In linear_search_scalar(), replace <code>arr[i] &lt; key</code> with <code>(arr[i] == key) * i</code>.
Presumably, this allows the loop to just do one non-trivial addition operation (or none if the item isn't to be found) instead of multiple.
Give it a try!</p>
					</div>
					</div>
				</div>
			</li>
		</ul>
	<section>
	<div display="none" id="pcs-comment-notreply-helper" />
	<form id="pcs-comment-form" action="#">
		<fieldset>
		<legend>Add a Comment</legend>
		<div id="pcs-comment-tab-inputs">
			<input type="hidden" id="pcs-comment-form-input-replyto"/>
			<label for="pcs-comment-form-input-name">Name</label>
			<input  id="pcs-comment-form-input-name" type="text" size="40" placeholder="Enter your name or nickname" />
			<br/>
			<label for="pcs-comment-form-input-website">Website</label>
			<input  id="pcs-comment-form-input-website" type="text" size="40" placeholder="Enter your website (optional)" />
			<br/>
			<label for="pcs-comment-form-input-empty">Empty</label>
			<input  id="pcs-comment-form-input-empty" type="text" size="30" placeholder="Do NOT enter anything here!" />
			<label   for="pcs-comment-form-input-textarea">Your Comment</label>
			<br/>
			<textarea id="pcs-comment-form-input-textarea" rows="7" cols="40" placeholder="Enter your comment (markdown is allowed)"></textarea>
		</div>
		<div id="pcs-comment-tab-message" style="display:none">
			<textarea readonly rows="10" cols="40"></textarea>
		</div>

		<button type="submit"
				id="pcs-comment-form-button-submit"
				title="Create mailto link and open it in default email client &#10;Note: you have to send the email to post comment"
				>Post via email</button>
		<button type="button"
				id="pcs-comment-form-button-message"
				title="See the text of email message to be sent &#10;Note: you can copy it and send manually"
				onclick="CommentSystem.viewEmail(&quot;performance-comparison-linear-search-vs-binary-search&quot;);"
				>View email text</button>
		<a target="_blank"
				id="pcs-comment-gmail-config-help"
				title="How to configure Chrome to open mailto links in Gmail..."
				href="https://productforums.google.com/forum/#!topic/gmail/JtWVPbUfh-o"
				>?</a>
		</fieldset>

		<!--			<a href="https://dirtyhandscoding.github.io/feeds/comment.performance-comparison-linear-search-vs-binary-search.atom.xml">
				Comment Atom Feed
			</a>
-->
	</form>
	<script>CommentSystem.displayReplyTo();</script>
</section>

	</div>
	<script>
		$('#pcs-comments').css({display: "none"});
		$('#pcs-comments-collapse-button').addClass('collapsed');
	</script>
</section>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, customized to personal taste.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>