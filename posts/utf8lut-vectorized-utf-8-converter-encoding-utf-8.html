<!DOCTYPE html>
<html lang="en">
<head>
        <!-- load favicon from /images -->
        <link rel="icon" type="image/png" href="/images/favicon.png" />
        <!-- stgatilov: properly detect device width on a mobile -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 

        <meta charset="utf-8" />
        <title>utf8lut: Vectorized UTF-8 converter. Encoding UTF-8</title>
        <link rel="stylesheet" href="https://dirtyhandscoding.github.io/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dirty hands coding Atom Feed" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Dirty hands coding RSS Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://dirtyhandscoding.github.io/">Dirty hands coding </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">ARCHIVES</a></li>
                    <li><a href="/categories.html">CATEGORIES</a></li>
                    <li><a href="/tags.html">TAGS</a></li>
                    <li><a href="/pages/contact.html">CONTACT</a></li>
                </ul>
<form class="navbar-search" action="https://dirtyhandscoding.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);">
                        <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">
                    </form>
                </nav>
<div id="submenu">
                    <ul>
                            <li><a href="https://dirtyhandscoding.github.io/category/cc.html">C/C++</a></li>
                            <li class="active"><a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/the-dark-mod.html">The Dark Mod</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/uncategorized.html">Uncategorized</a></li>
                    </ul>
                <div>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-encoding-utf-8.html" rel="bookmark"
           title="Permalink to utf8lut: Vectorized UTF-8 converter. Encoding UTF-8">utf8lut: Vectorized UTF-8 converter. Encoding UTF-8</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>04 August 2019</span>
	        <span>| in <a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></span>
<span>| tags: <a href="https://dirtyhandscoding.github.io/tag/unicode.html">unicode</a><a href="https://dirtyhandscoding.github.io/tag/simd.html">simd</a><a href="https://dirtyhandscoding.github.io/tag/lut.html">lut</a></span>
</footer><!-- /.post-info -->          <div class="series-summary series-in-article">
        <p>This article is part 3 of the <span class="series-name">utf8lut: Vectorized UTF-8 converter</span> series:</p>
            <ol class="parts">
        <li >
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-introduction.html'>Introduction</a>
        </li>
        <li >
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-decoding-utf-8.html'>Decoding UTF-8</a>
        </li>
        <li class="active">
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-encoding-utf-8.html'>Encoding UTF-8</a>
        </li>
        <li >
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-technical-details.html'>Technical details</a>
        </li>
        <li >
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-test-results.html'>Test results</a>
        </li>
    </ol>

    </div>

      <p>Conversion from UTF-16 to UTF-8 will be covered in this article. Since the fast path supports only basic plane, we don't need to convert surrogate pairs. Converting from UTF-32 works the same way, but two times more data is read per iteration and it is compressed into UTF-16 format first.</p>
<!--more-->

<p>The images in this article represent binary or hexadecimal numbers in big-endian convention as usual in math, while all sequences of bytes or words are shown in little-endian as they are laid in memory.</p>
<h2 id="idea"><a class="toclink" href="#idea">Idea</a></h2>
<p>The encoding algorithm will follow the same general idea (as described in <a href="https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-decoding-utf-8.html#idea">the previous part</a>): we extract information into a bitmask, then shuffle using precomputed control register. One notable difference is that since all supported UTF-16 characters are two bytes long, it is possible to process all 16 bytes of input at each iteration. However, UTF-8 output may be larger than UTF-16 input if three-byte characters are present, in which case output from one iteration may not fit into 16 bytes. For this reason, we will start with a code path supporting only one- and two- byte UTF-8 characters, and then will extend it to three-byte characters.</p>
<hr>
<h3 id="input-data-up-to-u07ff"><a class="toclink" href="#input-data-up-to-u07ff">Input data (up to U+07FF)</a></h3>
<p>Consider sample text: <strong>α+β-q=ελ (1)</strong></p>
<p>Here Greek letters take two bytes in UTF-8, and other characters are ASCII. We are more interested in UTF-16 representation, which is <code>\03B1\002B\03B2\002D\0071\003D\03B5\03BB\0020\0028\0031\0029</code>. The image below shows classification of bytes/words, assuming little-endian version of UTF-16.</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/classification_bits.svg" class="w450"/>
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/bytes2_classification.svg" class="w500"/>
</div>

<h3 id="get-lut-index"><a class="toclink" href="#get-lut-index">Get LUT index</a></h3>
<p>First of all, we shift every 16-bit word right by 6 bits. It can probably be avoided right now, but this data will be helpful later for composing the second byte in UTF-8 characters.</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pSource</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levelA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reg</span><span class="p">;</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levelB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_srli_epi16</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
</code></pre></div>

<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/lut_index2.svg" class="w450"/>
</div>

<p>The two-byte UTF-8 characters can be easily detected by looking which words are larger than 0x007F. This is equivalent to <code>levelB</code> having any bit set, except for the lowest one:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">lenGe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpgt_epi16</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x0001U</span><span class="p">));</span>
</code></pre></div>

<p>This results in a bitmask with 8 words, each spanning two bytes. Ideally, we should use<code>_mm_movemask_epi16</code> intrinsic to extract one bit from every 16-bit word, but such instruction does not exist in SSE. So we compact lower bytes using a byte shuffle and use <code>_mm_movemask_epi8</code> instead:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">lensAll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">lenGe2</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_setr_epi8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">));</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">lensAll</span><span class="p">);</span>
</code></pre></div>

<h3 id="fetch-from-lut"><a class="toclink" href="#fetch-from-lut">Fetch from LUT</a></h3>
<p>Now <code>mask</code> is a bitmask ranging from 0 to 255, and we use it for indexing a lookup table:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">EncoderLutEntry</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lutTable</span><span class="p">[</span><span class="n">mask</span><span class="p">];</span>
</code></pre></div>

<p>If <code>EncoderLutEntry</code> is large, multiplication by size is inserted on assembly level. It can be spared by tweaking shuffle mask for <code>lensAll</code>.</p>
<h3 id="shuffle"><a class="toclink" href="#shuffle">Shuffle</a></h3>
<p>If you recall how UTF-8 is encoded (see <a href="https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-decoding-utf-8.html#input-data">table from previous part</a>), you will notice that the lower bits of UTF-8 output can be taken from the lower bits of <code>levelA</code> and <code>levelB</code> variables. The higher bits can then be overwritten with proper UTF-8 byte headers.</p>
<p>SSE shuffle only operates on 16-byte registers, so both input and output must fit into 16 bytes. Since we consider every output character to take 1 or 2 bytes in UTF-8, the output surely fits into 16-byte register. As for <code>levelA</code> and <code>levelB</code> values, each of them contains eight 16-bit words, but we only need the lower half from every word. Hence, we can mix all of these lower bytes together into one register:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">levBA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_slli_epi16</span><span class="p">(</span><span class="n">levelA</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>
</code></pre></div>

<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/levels2.svg" class="w700"/>
</div>

<p>Now these bytes can be shuffled using the mask fetched from LUT:</p>
<p>The mask only depends on which words are ASCII and which are not, and this information is present in the bitmask <code>mask</code> used as index, so proper lookup table can indeed be constructed.</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">levBA</span><span class="p">,</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="n">shuf</span><span class="p">);</span>
</code></pre></div>

<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/shuffle2.svg" class="w500"/>
</div>

<h3 id="fix-headers"><a class="toclink" href="#fix-headers">Fix headers</a></h3>
<p>It remains only to overwrite the higher bits with UTF-8 headers, and UTF-16 output will be obtained. This is achieved in the same way as we <a href="https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-decoding-utf-8.html#validation">validated headers in decoding</a>. LUT entry contains a 16-byte bitmask, showing which of the bits must be overwritten (depending on which bytes are 1-byte start, 2-byte start, or continuation byte). Only the last bit of the header is zero, so multiplying the bitmask by two produces the header itself.</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="n">headerMask</span><span class="p">;</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_add_epi8</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="p">));</span>
</code></pre></div>

<h3 id="advance-pointers"><a class="toclink" href="#advance-pointers">Advance pointers</a></h3>
<p>Since we always process the whole 16-bytes of input, advancing input pointer is trivial. As for output pointer, we can put the number of bytes encoded into the LUT entry, since it varies depending on the type of characters.</p>
<div class="highlight"><pre><span></span><code><span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pDest</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span>
<span class="n">pDest</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="n">dstStep</span><span class="p">;</span>
<span class="n">pSource</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</code></pre></div>

<p>This is all for encoding characters up to U+07FF.
Now let's see how supporting three-byte characters changes the algorithm.</p>
<hr>
<h3 id="three-byte-characters"><a class="toclink" href="#three-byte-characters">Three-byte characters</a></h3>
<p>The main problem with three-byte characters is that the output from 16 bytes of input can take up to 24 bytes of output, i.e. the data is expanding due to these characters. Since we cannot do our fancy shuffles across 24 bytes, we have to split input data into two halves: each half contains 8 bytes, being four UTF-16 words. These halves are processed independently most of the time, although for better performance we still try to process them together where possible.</p>
<p>Another thing to note is that third level is added. Previously, we had <code>levelA</code> and <code>levelB</code> variables, aligned to 0-th and 6-th bits respectively. Now we also have <code>levelC</code> aligned to 12-th bit, which should go into shuffling to produce first bytes of the three-byte UTF-8 characters.</p>
<h3 id="input-data-up-to-uffff"><a class="toclink" href="#input-data-up-to-uffff">Input data (up to U+FFFF)</a></h3>
<p>Consider a string: <strong>∫∂α◎∂t≤β∓λ</strong></p>
<p>Its UTF-16 representation is <code>\222B\2202\03B1\25CE\2202\0074\2264\03B2\2213\03BB</code>.</p>
<p>Here is how it looks in bytes, with every byte colored by its type:</p>
<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/classification_bits.svg" class="w450"/>
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/bytes3_classification.svg" class="w500"/>
</div>

<h3 id="lut-indices"><a class="toclink" href="#lut-indices">LUT indices</a></h3>
<p>We need full information about byte-lengths of all input characters. Every character will take 2 bits in the LUT index with three possible values. It does not matter how the these possible values look exactly, as long as they are different for every byte length. I tried several ways and chose the one which looked fastest to me.</p>
<p>First, let's check which characters won't fit into 1 byte, and which characters won't fit into 2 bytes. This is done easily by comparing either the original word or the <code>levelB</code> shifted value against a threshold:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pSource</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levelB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_srli_epi16</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">lenGe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpgt_epi16</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x0001U</span><span class="p">));</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">lenGe3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpgt_epi16</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x001FU</span><span class="p">));</span>
</code></pre></div>

<p>These two bitmasks together contain all the information we need, but they take 32 bytes. Obviously, they contains 16 words, each being 0x0000 or 0xFFFF. So we can compress every word into a byte and combine these bitmasks together:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">lensMix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">_mm_srli_epi16</span><span class="p">(</span><span class="n">lenGe3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">lenGe2</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">allMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">lensMix</span><span class="p">);</span>
</code></pre></div>

<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/lut_index3.svg" class="w600"/>
</div>

<p>The lower 8 bits of <code>allMask</code> correspond to the first four characters, and the higher 8 bits correspond to the last four characters. Since shuffling would be performed separately for these halves, we should split them now:</p>
<div class="highlight"><pre><span></span><code><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">allMask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">255U</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">allMask</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8U</span><span class="p">);</span>
</code></pre></div>

<h3 id="shuffles"><a class="toclink" href="#shuffles">Shuffles</a></h3>
<p>The values to be shuffled are not ready yet. Since we shuffle each half separately, we want to obtain two 16-byte values: one should contain all the needed bytes for the first four characters, and another one should contain same data for the last four characters. For every character we need three bytes:</p>
<ul>
<li><em>(A)</em> byte with word's 7 lowest bits</li>
<li><em>(B)</em> byte with bits 6-11 of the word</li>
<li><em>(C)</em> byte with word's 4 highest bits</li>
</ul>
<p>As usual, there are many ways to achieve this, and I'll show the one I found to be the fastest. First, let's take the original data and shift right by 4 bits the higher byte in every word. There is no SSE instruction to shift only odd bytes, but we can emulate it using <code>_mm_maddubs_epi16</code> intrinsic:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">levAC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_maddubs_epi16</span><span class="p">(</span><span class="n">_mm_and_si128</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0xF0FFU</span><span class="p">)),</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x1001U</span><span class="p">));</span>
</code></pre></div>

<p>Now <code>levAC</code> contains 8 words, and every word has <em>(A)</em> in its lower byte and <em>(C)</em> in its higher byte. Recall that we have already computed <em>(B)</em> in <code>levelB</code> variable when producing LUT index. Now we combine lower halves of these variables into <code>level0</code>, and higher halves into <code>level1</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">levels0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_unpacklo_epi64</span><span class="p">(</span><span class="n">levAC</span><span class="p">,</span><span class="w"> </span><span class="n">levelB</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levels1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_unpackhi_epi64</span><span class="p">(</span><span class="n">levAC</span><span class="p">,</span><span class="w"> </span><span class="n">levelB</span><span class="p">);</span>
</code></pre></div>

<div class="center-content">
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/levels3.svg" class="w700"/>
    <img src="https://dirtyhandscoding.github.io/images/8_utf8lut_3_encode/shuffle3.svg" class="w500"/>
</div>

<p>It does not matter how exactly the <em>(A)</em>, <em>(B)</em>, <em>(C)</em> bytes are packed in these values, as long as you properly account for their order when precomputing the shuffle mask.
From now on, the processing is done separately for two halves. Shuffling allows us to move every byte into its final place in the UTF-8 output:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">EncoderLutEntry</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lutTable</span><span class="p">[</span><span class="n">mask0</span><span class="p">];</span>
<span class="k">const</span><span class="w"> </span><span class="n">EncoderLutEntry</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lutTable</span><span class="p">[</span><span class="n">mask1</span><span class="p">];</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">levels0</span><span class="p">,</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">shuf</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">levels1</span><span class="p">,</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">shuf</span><span class="p">);</span>
</code></pre></div>

<h3 id="headers-and-pointers"><a class="toclink" href="#headers-and-pointers">Headers and pointers</a></h3>
<p>For every byte, we overwrite 1-4 highest bits with UTF-8 header:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">header0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">headerMask</span><span class="p">;</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">header1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">headerMask</span><span class="p">;</span>
<span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">header0</span><span class="p">,</span><span class="w"> </span><span class="n">res0</span><span class="p">);</span>
<span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">header1</span><span class="p">,</span><span class="w"> </span><span class="n">res1</span><span class="p">);</span>
<span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">res0</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_add_epi8</span><span class="p">(</span><span class="n">header0</span><span class="p">,</span><span class="w"> </span><span class="n">header0</span><span class="p">));</span>
<span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_add_epi8</span><span class="p">(</span><span class="n">header1</span><span class="p">,</span><span class="w"> </span><span class="n">header1</span><span class="p">));</span>
</code></pre></div>

<p>Lastly, we store every half separately and advance pointers. Of course, these instructions must be done in proper sequence:</p>
<div class="highlight"><pre><span></span><code><span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pDest</span><span class="p">,</span><span class="w"> </span><span class="n">res0</span><span class="p">);</span>
<span class="n">pDest</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">dstStep</span><span class="p">;</span>
<span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pDest</span><span class="p">,</span><span class="w"> </span><span class="n">res1</span><span class="p">);</span>
<span class="n">pDest</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">dstStep</span><span class="p">;</span>
<span class="n">pSource</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</code></pre></div>

<p>Here finishes UTF-8 encoding algorithm with support for the whole BMP.</p>
<hr>
<h2 id="validation"><a class="toclink" href="#validation">Validation</a></h2>
<p>Unlike UTF-8, validation of UTF-16 input is very simple.
<strong>Surrogate words</strong> is the only possible problem in the input. They are the code points in range <code>[0xD800..U+E000)</code>, and we can check for them easily at the very beginning:</p>
<div class="highlight"><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_sub_epi16</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x5800U</span><span class="p">));</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">_mm_cmplt_epi16</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x8800U</span><span class="p">)))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</code></pre></div>

<p>Here we use the <a href="https://stackoverflow.com/a/17095534/556899">same trick</a> as before for checking range inclusion with one comparison.</p>
<h2 id="full-code"><a class="toclink" href="#full-code">Full code</a></h2>
<p>Here is the full listing again, with whole BMP support and validation:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kr">__m128i</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_loadu_si128</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pSource</span><span class="p">);</span>

<span class="c1">//validate input</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_sub_epi16</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x5800U</span><span class="p">));</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">_mm_cmplt_epi16</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x8800U</span><span class="p">)))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="c1">//encode input</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levelB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_srli_epi16</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">lenGe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpgt_epi16</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x0001U</span><span class="p">));</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">lenGe3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_cmpgt_epi16</span><span class="p">(</span><span class="n">levelB</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x001FU</span><span class="p">));</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">lensMix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">_mm_srli_epi16</span><span class="p">(</span><span class="n">lenGe3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">lenGe2</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">allMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">lensMix</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">allMask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">255U</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">allMask</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8U</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levAC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_maddubs_epi16</span><span class="p">(</span><span class="n">_mm_and_si128</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0xF0FFU</span><span class="p">)),</span><span class="w"> </span><span class="n">_mm_set1_epi16</span><span class="p">(</span><span class="mh">0x1001U</span><span class="p">));</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levels0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_unpacklo_epi64</span><span class="p">(</span><span class="n">levAC</span><span class="p">,</span><span class="w"> </span><span class="n">levelB</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">levels1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_unpackhi_epi64</span><span class="p">(</span><span class="n">levAC</span><span class="p">,</span><span class="w"> </span><span class="n">levelB</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">EncoderLutEntry</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lutTable</span><span class="p">[</span><span class="n">mask0</span><span class="p">];</span>
<span class="k">const</span><span class="w"> </span><span class="n">EncoderLutEntry</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lutTable</span><span class="p">[</span><span class="n">mask1</span><span class="p">];</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">levels0</span><span class="p">,</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">shuf</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_shuffle_epi8</span><span class="p">(</span><span class="n">levels1</span><span class="p">,</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">shuf</span><span class="p">);</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">header0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">headerMask</span><span class="p">;</span>
<span class="kr">__m128i</span><span class="w"> </span><span class="n">header1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">headerMask</span><span class="p">;</span>
<span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">header0</span><span class="p">,</span><span class="w"> </span><span class="n">res0</span><span class="p">);</span>
<span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_andnot_si128</span><span class="p">(</span><span class="n">header1</span><span class="p">,</span><span class="w"> </span><span class="n">res1</span><span class="p">);</span>
<span class="n">res0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">res0</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_add_epi8</span><span class="p">(</span><span class="n">header0</span><span class="p">,</span><span class="w"> </span><span class="n">header0</span><span class="p">));</span>
<span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_xor_si128</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">_mm_add_epi8</span><span class="p">(</span><span class="n">header1</span><span class="p">,</span><span class="w"> </span><span class="n">header1</span><span class="p">));</span>

<span class="c1">//advance</span>
<span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pDest</span><span class="p">,</span><span class="w"> </span><span class="n">res0</span><span class="p">);</span>
<span class="n">pDest</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lookup0</span><span class="p">.</span><span class="n">dstStep</span><span class="p">;</span>
<span class="n">_mm_storeu_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pDest</span><span class="p">,</span><span class="w"> </span><span class="n">res1</span><span class="p">);</span>
<span class="n">pDest</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lookup1</span><span class="p">.</span><span class="n">dstStep</span><span class="p">;</span>
<span class="n">pSource</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>Note that this time lookup table contains only 256 entries. So even with 64 bytes per entry, it takes only 16 KB of space.</p>
<h2 id="utf8lut-code"><a class="toclink" href="#utf8lut-code">utf8lut code</a></h2>
<p>The algorithm described above is used at the "core" of the utf8lut library. The relevant files are:</p>
<ul>
<li><a href="https://github.com/stgatilov/utf8lut/blob/master/src/core/EncoderProcess.h">core/EncoderProcess.h</a>: the algorithm for encoding UTF-8</li>
<li><a href="https://github.com/stgatilov/utf8lut/blob/master/src/core/EncoderLut.h">core/EncoderLut.h</a>: lookup table data types</li>
<li><a href="https://github.com/stgatilov/utf8lut/blob/master/src/core/EncoderLut.cpp">core/EncoderLut.cpp</a>: lookup table generation code</li>
</ul>
<p>While the article concentrates on the most powerful full-BMP validating code path, the library allows to disable some features for faster processing.</p>
          <div class="series-neighbors">
        <p class="series-prev">
            <span class="arrow-left"></span>
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-decoding-utf-8.html'>
                Part 2: Decoding UTF-8
            </a>
        </p>
        <p class="series-next">
            <a href='https://dirtyhandscoding.github.io/posts/utf8lut-vectorized-utf-8-converter-technical-details.html'>
                Part 4: Technical details
            </a>
            <span class="arrow-right"></span>
        </p>
    </div>

    </div><!-- /.entry-content -->
    
    			<!--<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.4.min.js"></script>-->
		<script src="https://dirtyhandscoding.github.io/theme/js/jquery.min.js"></script>
	<script type="text/javascript" src="https://dirtyhandscoding.github.io/theme/pelican_comment_system/comments.js"></script>
	<script type="text/javascript">
		$(document).ready(function() {
			CommentSystem.email_user   = "itiswrongemail";
			CommentSystem.email_domain = "outlook.com";

			$('#pcs-comment-form').on("submit",
				function( event )
				{
					event.preventDefault();
					$(location).attr('href', CommentSystem.getMailtoLink("utf8lut-vectorized-utf-8-converter-encoding-utf-8"));
				}
			);
		});
	</script>

    	<section>
	<div id="pcs-comments-header" class="inline-menu">
	<header>
		<div>Comments (0)</div>
		<button type="button" title="Expand or collapse the comments section" class="icon-label" id="pcs-comments-collapse-button" onclick="CommentSystem.collapsible($('#pcs-comments'), $(this));">
			<span class="nocss">expand</span>
		</button>
			<a href="https://dirtyhandscoding.github.io/feeds/comment.utf8lut-vectorized-utf-8-converter-encoding-utf-8.atom.xml" class="icon-label">atom feed: comments</a>
	</header>
	</div>
	<div id="pcs-comments">
		<p>There are no comments yet.</p>
	<section>
	<div display="none" id="pcs-comment-notreply-helper" />
	<form id="pcs-comment-form" action="#">
		<fieldset>
		<legend>Add a Comment</legend>
		<div id="pcs-comment-tab-inputs">
			<input type="hidden" id="pcs-comment-form-input-replyto"/>
			<label for="pcs-comment-form-input-name">Name</label>
			<input  id="pcs-comment-form-input-name" type="text" size="40" placeholder="Enter your name or nickname" />
			<br/>
			<label for="pcs-comment-form-input-website">Website</label>
			<input  id="pcs-comment-form-input-website" type="text" size="40" placeholder="Enter your website (optional)" />
			<br/>
			<label for="pcs-comment-form-input-empty">Empty</label>
			<input  id="pcs-comment-form-input-empty" type="text" size="30" placeholder="Do NOT enter anything here!" />
			<label   for="pcs-comment-form-input-textarea">Your Comment</label>
			<br/>
			<textarea id="pcs-comment-form-input-textarea" rows="7" cols="40" placeholder="Enter your comment (markdown is allowed)"></textarea>
		</div>
		<div id="pcs-comment-tab-message" style="display:none">
			<textarea readonly rows="10" cols="40"></textarea>
		</div>

		<button type="submit"
				id="pcs-comment-form-button-submit"
				title="Create mailto link and open it in default email client &#10;Note: you have to send the email to post comment"
				>Post via email</button>
		<button type="button"
				id="pcs-comment-form-button-message"
				title="See the text of email message to be sent &#10;Note: you can copy it and send manually"
				onclick="CommentSystem.viewEmail(&quot;utf8lut-vectorized-utf-8-converter-encoding-utf-8&quot;);"
				>View email text</button>
		<a target="_blank"
				id="pcs-comment-gmail-config-help"
				title="How to configure Chrome to open mailto links in Gmail..."
				href="https://productforums.google.com/forum/#!topic/gmail/JtWVPbUfh-o"
				>?</a>
		</fieldset>

		<!--			<a href="https://dirtyhandscoding.github.io/feeds/comment.utf8lut-vectorized-utf-8-converter-encoding-utf-8.atom.xml">
				Comment Atom Feed
			</a>
-->
	</form>
	<script>CommentSystem.displayReplyTo();</script>
</section>

	</div>
	<script>
		$('#pcs-comments').css({display: "none"});
		$('#pcs-comments-collapse-button').addClass('collapsed');
	</script>
</section>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, customized to personal taste.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>