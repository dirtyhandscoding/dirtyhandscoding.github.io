<!DOCTYPE html>
<html lang="en">
<head>
        <!-- load favicon from /images -->
        <link rel="icon" type="image/png" href="/images/favicon.png" />
        <!-- stgatilov: properly detect device width on a mobile -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 

        <meta charset="utf-8" />
        <title>Vectorizing small fixed-size sort</title>
        <link rel="stylesheet" href="https://dirtyhandscoding.github.io/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dirty hands coding Atom Feed" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Dirty hands coding RSS Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://dirtyhandscoding.github.io/">Dirty hands coding </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">ARCHIVES</a></li>
                    <li><a href="/categories.html">CATEGORIES</a></li>
                    <li><a href="/tags.html">TAGS</a></li>
                    <li><a href="/pages/contact.html">CONTACT</a></li>
                </ul>
<form class="navbar-search" action="https://dirtyhandscoding.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);">
                        <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">
                    </form>
                </nav>
<div id="submenu">
                    <ul>
                            <li class="active"><a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/off-topic.html">Off-topic</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/the-dark-mod.html">The Dark Mod</a></li>
                    </ul>
                <div>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" rel="bookmark"
           title="Permalink to Vectorizing small fixed-size sort">Vectorizing small fixed-size sort</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>05 January 2018</span>
	        <span>| in <a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></span>
<span>| tags: <a href="https://dirtyhandscoding.github.io/tag/cmov.html">cmov</a><a href="https://dirtyhandscoding.github.io/tag/simd.html">simd</a><a href="https://dirtyhandscoding.github.io/tag/sort.html">sort</a></span>
</footer><!-- /.post-info -->      <p>After a long break, I can finally return to the topic which was started in the <a href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html">previous blog post</a>. </p>
<p>Imagine that we have a small array of compile-time constant size with integers. For instance, N = 32. And we want to sort it as fast as possible. What is the best solution for this problem?</p>
<p>The wisest of you would suggest simply using std::sort, because every modern implementation of it is well-optimized and contains special handling of small subarrays to accelerate the generic quicksort algorithm. The ones who don't trust libraries would suggest using insertion sort: this is the algorithm usually used to handle small cases in std::sort. The performance geeks and regular stackoverflow visitors would definitely point to sorting networks: every question like "the fastest way to sort K integers" ends up with a solution based on them (<a href="https://stackoverflow.com/questions/2786899/fastest-sort-of-fixed-length-6-int-array">N=6</a>, <a href="https://stackoverflow.com/questions/32172144/fastest-way-to-sort-10-numbers-numbers-are-32-bit">N=10</a>, <a href="https://stackoverflow.com/questions/19790522/very-fast-sorting-of-fixed-length-arrays-using-comparator-networks">what</a>, <a href="https://stackoverflow.com/questions/3901079/how-does-a-sorting-network-beat-generic-sorting-algorithms">why</a>). I'm going to present a much less known way to sort small arrays of 32-bit keys, with performance comparable to sorting networks.</p>


<p>In the previous blog post I wrote a list of things to look for if you want to implement an algorithm working fast on small data:</p>
<ol>
<li>Avoid branches whenever possible: unpredictable ones are very slow.</li>
<li>Reduce data dependency: this allows to fully utilize processing units in CPU pipeline.</li>
<li>Prefer simple data access and manipulation patterns: this allows to vectorize the algorithm.</li>
<li>Avoid complicated algorithms: they almost always fail on one of the previous points, and they sometimes do too much work for small inputs.</li>
</ol>

<h2 id="comparison-network"><a class="toclink" href="#comparison-network">Comparison network</a></h2>
<p>Consider the sample implementation. The best known sorting network for N = 16 was <a href="http://www.hanshq.net/knuth-cheque.html">invented by Green in 1969</a>, it contains 60 comparators which can be processed in 10 batches.</p>
<div class="highlight"><pre><span></span><span class="cp">#ifdef _MSC_VER</span>
    <span class="cp">#define MIN(x, y) (x &lt; y ? x : y)</span>
    <span class="cp">#define MAX(x, y) (x &lt; y ? y : x) </span>
    <span class="cp">#define COMPARATOR(i, j) {  \</span>
<span class="cp">        auto &amp;x = dstKeys[i];   \</span>
<span class="cp">        auto &amp;y = dstKeys[j];   \</span>
<span class="cp">        auto a = MIN(x, y);     \</span>
<span class="cp">        auto b = MAX(x, y);     \</span>
<span class="cp">        x = a;                  \</span>
<span class="cp">        y = b;                  \</span>
<span class="cp">    }</span>
<span class="cp">#else</span>
    <span class="cp">#define COMPARATOR(x,y) { int tmp; asm(                     \</span>
<span class="cp">        &quot;mov %0, %2 ; cmp %1, %0 ; cmovg %1, %0 ; cmovg %2, %1&quot; \</span>
<span class="cp">        : &quot;=r&quot; (dstKeys[x]), &quot;=r&quot; (dstKeys[y]), &quot;=r&quot; (tmp)      \</span>
<span class="cp">        : &quot;0&quot; (dstKeys[x]), &quot;1&quot; (dstKeys[y]) : &quot;cc&quot;             \</span>
<span class="cp">    ); }</span>
<span class="cp">#endif</span>

<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1">// ... (48 more comparators) ... </span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">COMPARATOR</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</pre></div>


<p>Notice all the hard work to implement comparators in efficient way. For MSVC, ordinary min/max implementation via ternary operator is OK (note: do not try to use <code>std::min</code> and <code>std::max</code>, they are <a href="https://randomascii.wordpress.com/2013/11/24/stdmin-causing-three-times-slowdown-on-vc/">not optimizer-friendly</a>). The same works well on ICC and Clang, according to <a href="https://godbolt.org/">gcc.godbolt</a>. But on GCC it does not generate <code>cmov</code>, so I had to copy/paste some piece of inline assembly from somewhere. Note that the version with branches is <strong>2.7</strong> times slower than branchess version with cmovs on my machine.</p>
<p>A sorting algorithm based on comparison network satisfies points 1, 2, and 4 of the list above. It can be implemented in branchless way, although you have be extremely careful and check assembly output to make sure that cmov instructions are actually generated. Comparison network was initially designed as a parallel algorithm, so a lot of comparisons can be done in parallel. Given that for a fixed and small size the whole network is usually fully unrolled, the CPU is free to schedule as many instructions as it can at every moment. Finally, the algorithm is as simple as "do the given list of compare-and-swap operations", so there is no overhead which could waste performance.</p>
<p>Only the point 3 is missing, because data access patterns are defined by the sorting network. As a result, sorting networks are hard to vectorize, although people still do it. For instance, here is <a href="https://stackoverflow.com/a/13666085/556899">in-register sort of six byte values</a>, and similarly, <a href="https://xhad1234.github.io/Parallel-Sort-Merge-Join-in-Peloton/">in-register merging of eight 32-bit integers</a> is possible.</p>
<h2 id="position-counting-sort"><a class="toclink" href="#position-counting-sort">Position-counting sort</a></h2>
<p>Luckily, there is a way which fits all the four points of the above list.</p>
<p>Imagine that all elements are distinct. For each element, we can easily determine its final location in the sorted array: it is simply the number of elements less than it. We can iterate over all the elements and compare them with the element under attention, and count number of "less" outcomes. This is very similar to the idea driving the linear search in <a href="https://dirtyhandscoding.github.io/posts/performance-comparison-linear-search-vs-binary-search.html">the previous article</a>. After destination position is computed for all elements, we can iterate over them and copy them exactly to the desired location.</p>
<p>Here is the illustration of counting less elements to compute final position:</p>
<p><img src="https://dirtyhandscoding.github.io/images/4_simd_small_sort/count_position1.png" class="centered w700" /></p>
<p>If equal elements are possible in the input array, then counting algorithm becomes more complicated. Let's try to make our sorting algorithm stable. Then the final position of element <em>A[i] = X</em> is equal to the number of elements less than <em>X</em> plus the number of elements equal to <em>X</em> located to the left of position <em>i</em>. It means that in addition to less elements, we also have to count number of equal elements, although only in about half of the array. This additional computation is inevitable, unless you are absolutely sure the input array has no duplicates.</p>
<p>The simple implementation of the suggested algorithm looks like this:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inKeys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inKeys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">elem</span><span class="p">);</span>
    <span class="n">dstKeys</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>How should this sorting algorithm be called? I have never seen anything like this before. However, while looking for Green's sorting network at <a href="https://github.com/Morwenn/cpp-sort">Morwenn's repository</a>, I stumbled upon <a href="https://github.com/Morwenn/cpp-sort/wiki/Original-research">a page</a> which contains an interesting link at the very end. It points to the so-called <a href="http://www.geocities.ws/p356spt/">"Exact sort"</a>, which is exactly what I described just above. I don't like this name, because it gives too much attention to the very last step of the algorithm (i.e. moving elements to their places). In my opinion, the element-counting mechanic is the much more important part of the algorithm, which will be evident in the next section. That's why I prefer to call it "position-counting sort" (<a href="https://en.wikipedia.org/wiki/Counting_sort">"counting sort"</a> is already taken).</p>
<p>Let's recall the sacred four points. The algorithm is very simple in its core. It has no branches if fully unrolled (recall: array size is small and compile-time constaint). Note that the comparison does not generate a branch in x86. Unrolling this code is not recommended, even without unrolling branches should be well-predicted. As for data dependencies: outer iterations are completely independent, the inner loops behave like the <a href="http://www.drdobbs.com/architecture-and-design/parallel-pattern-7-reduce/222000718">reduce</a> algorithm, so their iterations can be made quite independent from each other too. Finally, the data access patterns are very simple: inner loops access all elements sequentally (order does not even matter). This means that we can attempt to vectorize this algorithm.</p>
<h2 id="vectorization"><a class="toclink" href="#vectorization">Vectorization</a></h2>
<p>As just noted, data dependencies are rather weak across iterations of both loops. So it makes sense to vectorize both by iterations of inner and outer loops. Vectorization of inner iterations should produce something like:</p>
<div class="highlight"><pre><span></span><span class="kr">__m128i</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__m128i</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">inKeys</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">elem_x4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>At the end, horizontal sum of <code>cnt</code> register has to be computed to obtain the sought-for final position of the considered element. In order to reduce number of loads, make horizontal sum faster, and in general reduce the overhead of loops, we can also process the elements to be moved in packs of four. So in the outer loop we load four elements at once too.</p>
<p>Here is the plan (bottom half shows horizontal sum at the end):
<img src="https://dirtyhandscoding.github.io/images/4_simd_small_sort/vectorized_count2.png" class="centered w600" /></p>
<p>The code starts by iterating over the elements to be moved:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<p>Here is the body of the outer loop:</p>
<div class="highlight"><pre><span></span><span class="c1">//load four elements (to be moved into their locations)</span>
<span class="kr">__m128i</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//prepare a register with each value broadcasted</span>
<span class="kr">__m128i</span> <span class="n">reg0</span> <span class="o">=</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="kr">__m128i</span> <span class="n">reg1</span> <span class="o">=</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="kr">__m128i</span> <span class="n">reg2</span> <span class="o">=</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="kr">__m128i</span> <span class="n">reg3</span> <span class="o">=</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>

<span class="c1">//init one register with counters per each element considered</span>
<span class="kr">__m128i</span> <span class="n">cnt0</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
<span class="kr">__m128i</span> <span class="n">cnt1</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
<span class="kr">__m128i</span> <span class="n">cnt2</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
<span class="kr">__m128i</span> <span class="n">cnt3</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__m128i</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">inKeys</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="c1">//update counters for all four elements of *reg*</span>
    <span class="n">cnt0</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt0</span><span class="p">,</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg0</span><span class="p">));</span>
    <span class="n">cnt1</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt1</span><span class="p">,</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg1</span><span class="p">));</span>
    <span class="n">cnt2</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt2</span><span class="p">,</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg2</span><span class="p">));</span>
    <span class="n">cnt3</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt3</span><span class="p">,</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg3</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>Now we need to take equal elements into account. They are processed in very similar way, but only elements to the left of <code>i</code> are compared:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__m128i</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">inKeys</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">cnt0</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt0</span><span class="p">,</span> <span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg0</span><span class="p">));</span>
    <span class="n">cnt1</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt1</span><span class="p">,</span> <span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg1</span><span class="p">));</span>
    <span class="n">cnt2</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt2</span><span class="p">,</span> <span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg2</span><span class="p">));</span>
    <span class="n">cnt3</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt3</span><span class="p">,</span> <span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg3</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>Finally, there may be equal elements across elements <em>i, i+1, i+2, i+3</em>. We need to compare all elements in <code>reg</code> with each other, while carefully masking out the comparisons where operands go in wrong order:</p>
<div class="highlight"><pre><span></span><span class="c1">//cnt0 = _mm_sub_epi32(cnt0, _mm_and_si128(_mm_cmplt_epi32(reg, reg0), _mm_setr_epi32( 0,  0,  0,  0)));</span>
<span class="n">cnt1</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt1</span><span class="p">,</span> <span class="n">_mm_and_si128</span><span class="p">(</span><span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">reg1</span><span class="p">),</span> <span class="n">_mm_setr_epi32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">)));</span>
<span class="n">cnt2</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt2</span><span class="p">,</span> <span class="n">_mm_and_si128</span><span class="p">(</span><span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">reg2</span><span class="p">),</span> <span class="n">_mm_setr_epi32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">)));</span>
<span class="n">cnt3</span> <span class="o">=</span> <span class="n">_mm_sub_epi32</span><span class="p">(</span><span class="n">cnt3</span><span class="p">,</span> <span class="n">_mm_and_si128</span><span class="p">(</span><span class="n">_mm_cmpeq_epi32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">reg3</span><span class="p">),</span> <span class="n">_mm_setr_epi32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">)));</span>
</pre></div>


<p>Now all counts are gathered in XMM registers, and we have to calculate horizontal sum of each register. Since there are four of them, it makes sense to fully transpose them and then do a simple vertical sum:</p>
<div class="highlight"><pre><span></span><span class="c1">//4x4 matrix transpose in SSE</span>
<span class="kr">__m128i</span> <span class="n">c01L</span> <span class="o">=</span> <span class="n">_mm_unpacklo_epi32</span><span class="p">(</span><span class="n">cnt0</span><span class="p">,</span> <span class="n">cnt1</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">c01H</span> <span class="o">=</span> <span class="n">_mm_unpackhi_epi32</span><span class="p">(</span><span class="n">cnt0</span><span class="p">,</span> <span class="n">cnt1</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">c23L</span> <span class="o">=</span> <span class="n">_mm_unpacklo_epi32</span><span class="p">(</span><span class="n">cnt2</span><span class="p">,</span> <span class="n">cnt3</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">c23H</span> <span class="o">=</span> <span class="n">_mm_unpackhi_epi32</span><span class="p">(</span><span class="n">cnt2</span><span class="p">,</span> <span class="n">cnt3</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">cntX</span> <span class="o">=</span> <span class="n">_mm_unpacklo_epi64</span><span class="p">(</span><span class="n">c01L</span><span class="p">,</span> <span class="n">c23L</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">cntY</span> <span class="o">=</span> <span class="n">_mm_unpackhi_epi64</span><span class="p">(</span><span class="n">c01L</span><span class="p">,</span> <span class="n">c23L</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">cntZ</span> <span class="o">=</span> <span class="n">_mm_unpacklo_epi64</span><span class="p">(</span><span class="n">c01H</span><span class="p">,</span> <span class="n">c23H</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">cntW</span> <span class="o">=</span> <span class="n">_mm_unpackhi_epi64</span><span class="p">(</span><span class="n">c01H</span><span class="p">,</span> <span class="n">c23H</span><span class="p">);</span>
<span class="c1">//obtain four resulting counts</span>
<span class="kr">__m128i</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">cntX</span><span class="p">,</span> <span class="n">cntY</span><span class="p">),</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">cntZ</span><span class="p">,</span> <span class="n">cntW</span><span class="p">));</span>
</pre></div>


<p>Now we have final locations of all the four considered elements. We need only to extract them and move the elements to their places:</p>
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="n">k0</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_si32</span><span class="p">(</span><span class="n">cnt</span>   <span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k3</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k3</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
</pre></div>


<p>That's all!</p>
<h2 id="comparison"><a class="toclink" href="#comparison">Comparison</a></h2>
<p>Below you can see a barchart with performance comparison of all major implementations (on Ryzen 5 1600 with MSVC 2013 x64). Text label above each bar in format "1 / X" means than that the corresponding sort implementation takes X nanoseconds per call on average. In other words, its throughput is (1/X) sorts per nanosecond. The height of each bar is set as its throughput divided by throughput of std::sort (higher = faster).
<img src="https://dirtyhandscoding.github.io/images/4_simd_small_sort/res_general.png" class="centered w800" /></p>
<p>For instance, implementation <strong>PCSort_Main</strong> for N = 16 (dark green bar on the left) takes 41 nanoseconds per call, i.e. processes (1/41) calls per nanosecond. It is about 3.5 times faster than std::sort implementation.</p>
<p>The dashed bars correspond to implementations which work properly only on input arrays with all elements distinct.</p>
<p>Here is the explanation of different implementations:
<ol>
  <li><strong>SortingNetwork</strong>: branchless sorting networks. For N = 16 it is Green's network of size 6 (as described above), for N = 32 it is something built on top of it (taken from <a href="https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/sorting_network/sort32.h">here</a>).</li>
  <li><strong>PCSort_Main</strong>: the standard vectorized implementation of position-counting sort, exactly as described above.</li>
  <li><strong>PCSort_Optimized</strong>: combines counting less elements and equal elements to the left of considered position into counting less-or-equal elements. This optimization allows to process each element of array only once per outer iteration (while in <strong>PCSort_Main </strong>the elements to the left are processed twice).</li>
  <li><strong>PCSort_Trans</strong>: somewhat transposed implementation. A local array of N counters is created. The outer loop goes through the elements to compare with. The inner loop goes through the elements for which the final location is to be computed. During each outer loop, we have to pass through the array of counters and increase some of them. Note that optimization from <strong>PCSort_Optimized</strong> is already applied: each element is processed once per outer iteration.</li>
  <li><strong>PCSort_WideOuter</strong>: this implementation uses wider vectorization in the outer loop compared to <strong>PCSort_Main</strong>, it computes final location for 16 elements during one outer iteration. In the inner loop elements are loaded in packs of four, and each element is broadcasted to the whole register to make comparison. This implementation works only for distinct elements: supporting equal elements in it is a major pain.</li>
  <li><strong>PCSort_WideOuter</strong>: same as <strong>PCSort_WideOuter</strong>, but all loops are fully unrolled (works only for N = 16). To my surprise, it works slower than the version with loops.</li>
</ol></p>
<p>According to the data, the standard position-counting sort (<strong>PCSort_Main</strong>) is 20-25% faster than sorting network for N = 16 and N = 32. The optimized implementations are even better for larger N (+17% for N = 32, and +30% for N = 64). If you are sure that all elements are surely distinct, you can get additional +30% performance boost.
It is very important to note that the results differ a lot depending on compiler. 64-bit MSVC turned out to be the best compiler for position-counting sort, while network sort is much faster on 64-bit GCC (details in table below).</p>
<p>Below you can see performance plotted by N increasing. For each N and each method, the ratio of its speed to speed of std::sort is shown. For example, <strong>PCSort_Main</strong> is 3.5 times faster than std::sort for N = 16.</p>
<p><img src="https://dirtyhandscoding.github.io/images/4_simd_small_sort/res_byn.png" class="centered w600" /></p>
<p>As you see, the proposed sorting method is always faster than insertion sort, and the std::sort implementation catches up with proposed method only for N = 256 (or a bit later for optimized/distinct-only versions).</p>
<p>I also mesured performance across several compilers and CPUs. The difference between compilers is surprisingly noticeable! Here is the full table:
<div class="centered w500 center-content">
<table class="solid-cells">
   <caption>Time of one N=32 sort, in ns</caption>
   <tr>
    <th>Platform</th>
    <th>PC_Main</th>
    <th>PC_Opt</th>
    <th>Network</th>
    <th>Insertion</th>
   </tr>
   <tr><td>Ryzen5 + VC2013 x64</td><td>127.8</td><td>108.7</td><td>153.5</td><td>334.7</td></tr>
   <tr><td>Ryzen5 + VC2013 x32</td><td>154.5</td><td>128.7</td><td>174.5</td><td>341.4</td></tr>
   <tr><td>Ryzen5 + GCC7 x64 (VM)</td><td>119.4</td><td>127.3</td><td><strong>100.8</strong></td><td>347.4</td></tr>
   <tr><td>Ryzen5 + GCC5 x64 (VM)</td><td>120.0</td><td>118.6</td><td><strong>104.0</strong></td><td>350.3</td></tr>
   <tr><td>Ryzen5 + GCC7 x32 (VM)</td><td>140.4</td><td>118.7</td><td>154.7</td><td>430.7</td></tr>
   <tr><td>Ryzen5 + GCC5 x32 (VM)</td><td>139.9</td><td>126.4</td><td>150.6</td><td>427.0</td></tr>
   <tr><td>Ryzen5 + TDM GCC5 x32</td><td>137.3</td><td>123.0</td><td>145.0</td><td>356.7</td></tr>
   <tr><td>i3-5005U + VC2017 x64</td><td>293.7</td><td>240.3</td><td>324.2</td><td>644.7</td></tr>
   <tr><td>i3-5005U + VC2017 x32</td><td>272.8</td><td>213.6</td><td>392.0</td><td>651.4</td></tr>
   <tr><td>i3-5005U + VC2013 x32</td><td>282.3</td><td>224.1</td><td>387.2</td><td>670.4</td></tr>
   <tr><td>i3-5005U + VC2015 x32</td><td>276.6</td><td>213.6</td><td>392.0</td><td>649.5</td></tr>
</table>
</div></p>
<p>The list of CPUs used:
<ol>
  <li><strong>Ryzen5</strong>: Ryzen 5 1600, 3.2 GHz</li>
  <li><strong>i3-5005U</strong>: Intel i3-5005U, 2.0 GHz (Broadwell)</li>
</ol></p>
<p>The list of compilers used:
<ol>
  <li><strong>VC20xx</strong>: Microsoft Visual C++ of year 20xx (compiled with <code>cl.exe</code> with <code>/O2</code> parameter).</li>
  <li><strong>GCC7</strong>: GCC 7.1.0 inside VirtualBox VM with Ubuntu (with <code>-O3 -msse4</code>).</li>
  <li><strong>GCC5</strong>: GCC 5.4.0 inside VirtualBox VM with Ubuntu (with <code>-O3 -msse4</code>).</li>
  <li><strong>TDM GCC5</strong>: TDM GCC 5.1.0 on Windows (with <code>-O3 -msse4</code>).</li>
</ol></p>
<p>As you see, 64-bit GCC manages to get 1.5 times faster performance from the sorting network. I suppose it succeeds in fitting everything into registers, while 32-bit GCC and MSVC cannot avoid register stalls. 
The position-counting sort also benefits from 64-bit case, most likely also due to having more XMM registers available.</p>
<h2 id="discussion"><a class="toclink" href="#discussion">Discussion</a></h2>
<p>In practice, sorting only keys is rarely enough. In most cases each element consists of a key and an attached value, and an element must be moved as a whole during sort. There are <a href="https://en.wikipedia.org/wiki/AOS_and_SOA">two ways to store array of elements</a>: having single array of key-value pairs (array-of-structures, AoS) and having two separate arrays, one with keys and the other one with values (structure-of-arrays, SoA).</p>
<p>It is very easy to extend the proposed algorithm to process keys with attached values, given that elements are stored in SoA layout, i.e. values are stored in a separate array. Since the vectorized part determines the final position (index) of every element, it is enough to send the values to same positions as their keys:</p>
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="n">k0</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_si32</span><span class="p">(</span><span class="n">cnt</span>   <span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">k3</span> <span class="o">=</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
<span class="n">dstKeys</span><span class="p">[</span><span class="n">k3</span><span class="p">]</span> <span class="o">=</span> <span class="n">inKeys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
<span class="c1">//add this code to support values array:</span>
<span class="n">dstVals</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inVals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span>
<span class="n">dstVals</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inVals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">dstVals</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inVals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
<span class="n">dstVals</span><span class="p">[</span><span class="n">k3</span><span class="p">]</span> <span class="o">=</span> <span class="n">inVals</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
</pre></div>


<p>No computations are added for values at all! Only a minimal amount of additional time is spent for moving every value directly to its final location. It takes O(N) time, which is dominated by O(N^2) part for counting positions. Although the keys are restricted to be 32-bit integers (32-bit floats can be supported the same way), the values can be of any type.</p>
<p>As for performance measurements, adding support for 32-bit values increases time per one sort for <strong>PCSort_Main</strong>:</p>
<ul>
<li>from 41 ns to 47.7 ns (+16.3%) for N = 16</li>
<li>from 127.8 ns to 136.4 ns (+6.7%) for N = 32)</li>
<li>from 465.4 to 486.4 ns (+4.5%) for N = 64.</li>
</ul>
<p>Now compare it with sorting networks. Supporting values in a separate array (SoA) is more expensive: two additional CMOV operations must be added per one comparator (for swapping values conditionally). And it only works as long as the values are simple enough to be CMOV-ed.
If the values are 32-bit, then it is much easier to work with array-of-structures layout. Store value first, key then, and treat each key-value pair as 64-bit integer. Compare them as 64-bit integers and CMOV them as such, and you'll get values support for free on 64-bit platform.</p>
<h3 id="compiler-issue"><a class="toclink" href="#compiler-issue">Compiler issue</a></h3>
<p>I stumbled against a tiny compiler inefficiency. Visual C++ 64-bit compiler (and I guess other compilers too) generates unnecessary instruction for <code>_mm_extract_epi32</code> intrinsic. Look at the assembly code generated by compiler for extracting single position and moving a key to its final location:</p>
<div class="highlight"><pre><span></span><span class="c">; 113  :  unsigned k2 = _mm_extract_epi32(cnt, 2);</span>
<span class="c">; 117  :  dstKeys[k2] = inKeys[i+2];</span>

<span class="c">;load inKeys[i+2] to eax:</span>
<span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdx-16</span><span class="p">]</span>
<span class="c">;extract k2 to ecx:</span>
<span class="nf">pextrd</span>  <span class="no">ecx</span><span class="p">,</span> <span class="no">xmm2</span><span class="p">,</span> <span class="mi">2</span>
<span class="c">;zero-fill upper half of ecx</span>
<span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">ecx</span>
<span class="c">;store eax to dstKeys[k2]:</span>
<span class="nf">mov</span>     <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">r8</span><span class="err">+</span><span class="no">rcx</span><span class="p">*</span><span class="mi">4</span><span class="p">],</span> <span class="no">eax</span>
</pre></div>


<p>For the first glance, the third instruction seems to do nothing. However, it was specifically inserted by compiler here, in order to clear the upper 32 bits of rcx register. What compiler does not know is that <code>pextrd</code> instruction already clears the upper 32 bits of 64-bit destination register, so the instruction is excessive.
The performance impact is most likely minimal, but it is still strange to see such things. The same issue happens for <code><em>mm_movemask</em>*</code> intrinsics, see <a href="https://stackoverflow.com/questions/36017029/unnecessary-instructions-generated-for-mm-movemask-epi8-intrinsic-in-x64-mode">this question</a>.</p>
<h2 id="the-code"><a class="toclink" href="#the-code">The code</a></h2>
<p>As usual, all the materials and all the C++ code is available in <a href="https://github.com/stgatilov/position-counting-sort">position-counting-sort</a> repo on GitHub.</p>
<h2 id="conclusion"><a class="toclink" href="#conclusion">Conclusion</a></h2>
<p>The position-counting sorting algorithm is rather unknown, although it yields performance comparable to that of optimal sorting networks (which are well-known for their speed). It works in plain O(N^2) time, while sorting networks have to do somewhere between O(N log N) and O(N log^2 N) work. Having worse asymptotic complexity, it manages to be so fast only because it is vectorized very efficiently. So it can serve as a good alternative for sorting networks in some cases.</p>
    </div><!-- /.entry-content -->
    <section>
        <div id="post-share-links" class="inline-menu">
            <div>Share on:</div>
            <a href="https://twitter.com/intent/tweet?text=Vectorizing%20small%20fixed-size%20sort&url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share on Twitter">Twitter</a><!--
            --><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share on Facebook">Facebook</a><!--
            --><a href="https://plus.google.com/share?url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share on Google Plus">Google+</a><!--
            --><a href="https://sharetodiaspora.github.io/?title=Vectorizing%20small%20fixed-size%20sort&url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share on Diaspora">Diaspora*</a><!--
            --><a href="https://news.ycombinator.com/submitlink?t=Vectorizing%20small%20fixed-size%20sort&u=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share on HackerNews">HackerNews</a><!--
            --><a href="mailto:?subject=Vectorizing%20small%20fixed-size%20sort&amp;body=https%3A//dirtyhandscoding.github.io/posts/vectorizing-small-fixed-size-sort.html" target="_blank" class="icon-label" title="Share via Email">Email</a>
        </div>
    </section>
    
    			<!--<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.4.min.js"></script>-->
		<script src="https://dirtyhandscoding.github.io/theme/js/jquery.min.js"></script>
	<script type="text/javascript" src="https://dirtyhandscoding.github.io/theme/pelican_comment_system/comments.js"></script>
	<script type="text/javascript">
		$(document).ready(function() {
			CommentSystem.email_user   = "itiswrongemail";
			CommentSystem.email_domain = "outlook.com";

			$('#pcs-comment-form').on("submit",
				function( event )
				{
					event.preventDefault();
					$(location).attr('href', CommentSystem.getMailtoLink("vectorizing-small-fixed-size-sort"));
				}
			);
		});
	</script>

    	<section>
	<div id="pcs-comments-header" class="inline-menu">
	<header>
		<div>Comments (0)</div>
		<button type="button" title="Expand or collapse the comments section" class="icon-label" id="pcs-comments-collapse-button" onclick="CommentSystem.collapsible($('#pcs-comments'), $(this));">
			<span class="nocss">expand</span>
		</button>
			<a href="https://dirtyhandscoding.github.io/feeds/comment.vectorizing-small-fixed-size-sort.atom.xml" class="icon-label">atom feed: comments</a>
	</header>
	</div>
	<div id="pcs-comments">
		<p>There are no comments yet.</p>
	<section>
	<div display="none" id="pcs-comment-notreply-helper" />
	<form id="pcs-comment-form" action="#">
		<fieldset>
		<legend>Add a Comment</legend>
		<div id="pcs-comment-tab-inputs">
			<input type="hidden" id="pcs-comment-form-input-replyto"/>
			<label for="pcs-comment-form-input-name">Name</label>
			<input  id="pcs-comment-form-input-name" type="text" size="40" placeholder="Enter your name or nickname" />
			<br/>
			<label for="pcs-comment-form-input-website">Website</label>
			<input  id="pcs-comment-form-input-website" type="text" size="40" placeholder="Enter your website (optional)" />
			<br/>
			<label for="pcs-comment-form-input-empty">Empty</label>
			<input  id="pcs-comment-form-input-empty" type="text" size="30" placeholder="Do NOT enter anything here!" />
			<label   for="pcs-comment-form-input-textarea">Your Comment</label>
			<br/>
			<textarea id="pcs-comment-form-input-textarea" rows="7" cols="40" placeholder="Enter your comment (markdown is allowed)"></textarea>
		</div>
		<div id="pcs-comment-tab-message" style="display:none">
			<textarea readonly rows="10" cols="40"></textarea>
		</div>

		<button type="submit"
				id="pcs-comment-form-button-submit"
				title="Create mailto link and open it in default email client &#10;Note: you have to send the email to post comment"
				>Post via email</button>
		<button type="button"
				id="pcs-comment-form-button-message"
				title="See the text of email message to be sent &#10;Note: you can copy it and send manually"
				onclick="CommentSystem.viewEmail(&quot;vectorizing-small-fixed-size-sort&quot;);"
				>View email text</button>
		<a target="_blank"
				id="pcs-comment-gmail-config-help"
				title="How to configure Chrome to open mailto links in Gmail..."
				href="https://productforums.google.com/forum/#!topic/gmail/JtWVPbUfh-o"
				>?</a>
		</fieldset>

		<!--			<a href="https://dirtyhandscoding.github.io/feeds/comment.vectorizing-small-fixed-size-sort.atom.xml">
				Comment Atom Feed
			</a>
-->
	</form>
	<script>CommentSystem.displayReplyTo();</script>
</section>

	</div>
	<script>
		$('#pcs-comments').css({display: "none"});
		$('#pcs-comments-collapse-button').addClass('collapsed');
	</script>
</section>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, customized to personal taste.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>