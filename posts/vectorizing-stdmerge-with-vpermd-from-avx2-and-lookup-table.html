<!DOCTYPE html>
<html lang="en">
<head>
        <!-- load favicon from /images -->
        <link rel="icon" type="image/png" href="/images/favicon.png" />
        <!-- stgatilov: properly detect device width on a mobile -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 

        <meta charset="utf-8" />
        <title>Vectorizing std::merge with vpermd from AVX2 and lookup table</title>
        <link rel="stylesheet" href="https://dirtyhandscoding.github.io/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dirty hands coding Atom Feed" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Dirty hands coding RSS Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://dirtyhandscoding.github.io/">Dirty hands coding </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">ARCHIVES</a></li>
                    <li><a href="/categories.html">CATEGORIES</a></li>
                    <li><a href="/tags.html">TAGS</a></li>
                    <li><a href="/pages/contact.html">CONTACT</a></li>
                </ul>
<form class="navbar-search" action="https://dirtyhandscoding.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);">
                        <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">
                    </form>
                </nav>
<div id="submenu">
                    <ul>
                            <li class="active"><a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/the-dark-mod.html">The Dark Mod</a></li>
                            <li><a href="https://dirtyhandscoding.github.io/category/uncategorized.html">Uncategorized</a></li>
                    </ul>
                <div>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" rel="bookmark"
           title="Permalink to Vectorizing std::merge with vpermd from AVX2 and lookup table">Vectorizing std::merge with vpermd from AVX2 and lookup table</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>02 August 2017</span>
	        <span>| in <a href="https://dirtyhandscoding.github.io/category/high-performance.html">High performance</a></span>
<span>| tags: <a href="https://dirtyhandscoding.github.io/tag/avx.html">avx</a><a href="https://dirtyhandscoding.github.io/tag/simd.html">simd</a><a href="https://dirtyhandscoding.github.io/tag/sort.html">sort</a></span>
</footer><!-- /.post-info -->      
      <p>Recently I stumbled upon <a href="https://stackoverflow.com/questions/43253036/computing-size-of-symmetric-difference-of-two-sorted-arrays-using-simd-avx">a question on stackoverflow</a>, which asked how to vectorize computing symmetric difference of two sorted int32 arrays using AVX2. I decided to try doing it myself, and this post is about what I achieved. Of course, the best way to compute symmetric difference of sorted sets is by running ordinary <a href="https://en.wikipedia.org/wiki/Merge_algorithm">merge algorithm</a> (e.g. with std::merge) for the arrays plus some simple postprocessing. I'll concentrate only on the generic merging algorithm here.</p>
<p>I'll handle 32-bit integer keys only. Having keys of larger size would reduce significantly the efficiency of the algorithm (as usual with vectorization). Using 32-bit floating point keys is not much different from using integer keys; moreover, sorting 32-bit floats can be easily reduced to sorting 32-bit integers, which is often used to run radix sort on floating point data (see <a href="http://stereopsis.com/radix.html">this</a> and <a href="http://codercorner.com/RadixSortRevisited.htm">that</a>). Also I'll briefly discuss the case when 32-bit values are attached to 32-bit keys (sorting without values is pretty useless in practice).</p>


<h2 id="better-scalar-code"><a class="toclink" href="#better-scalar-code">Better scalar code</a></h2>
<p>Before trying to vectorize the algorithm, let's try to see how fast scalar implementation can be. Here is a simple implementation of merging algorithm:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Merge_ScalarTrivial</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">aCnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bCnt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">aCnt</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bCnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bArr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">aArr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bArr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">aArr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">aCnt</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="p">(</span><span class="n">aCnt</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">bArr</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">bCnt</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bCnt</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The first possible improvement is about termination criterion. Since the inner loop is tiny, checking <code>i &lt; aCnt</code> and <code>j &lt; bCnt</code> can take noticeable time (note also that both i and j grow unpredictably). This can be improved in one of three ways:
<ol>
    <li>Add sentinel element (INT_MAX) immediately after each input array, so that we can iterate by k in range [0 .. aCnt + bCnt). This approach is great, and the main drawback is that it forces us to copy the whole input if we cannot freely overwrite such after-the-end elements.</li>
    <li>Do iterations in blocks of size 32 (for instance). Just replace the condition of while with <code>i &lt;= aCnt - 32 &amp;&amp; j &lt;= bCnt - 32</code>, and add second loop <code>for (int t = 0; t &lt; 32; t++)</code> just inside the first one. This way the innermost loop has simple stop criterion <code>t &lt; 32</code>, and the outer loop terminates when it cannot be guaranteed that the inner loop won't get out of any input array. The remaining iterations are processed in the usual way, which is not very nice of course (there can be many iterations remaining).</li>
    <li><em>(taken).</em> Carefully detect when exactly the loop finishes. In order to achieve this: find which input array has greater last element, then iterate back from that element to detect all elements which get into memcpy-ed tail. Given that number of such elements is X, we can freely replace the loop with <code>for (int k = 0; k &lt; aCnt + bCnt - X;)</code>. In future with vectorization, we'll have to generalize this approach so that at least four elements are always available in the inner loop: this is achieved by doing merge in reversed order (from the ends of both arrays) until both arrays have at least four elements processed. </li>
</ol></p>
<p>The second improvement is removal of branch <code>if (aArr[i] &lt; bArr[j])</code>. This branch is completely unpredictable if the input arrays are randomly interleaved, which makes CPU do excessive work and increases latency of each iteration. In order to determine which element must be stored into <code>dst[k]</code>, it is enough to use ternary operator, which would compile into cmov instruction. In order to increment i and j counters, we can add boolean results of some comparisons to both of them, which would compile into setXX instructions.</p>
<p>These two changes reduce average time per element from <strong>6.5</strong> ns to <strong>4.75</strong> ns (on random inputs, on my laptop). Here is the resulting code:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Merge_ScalarBranchless_3</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">aCnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bCnt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//let&#39;s assume values = INT_MIN are forbidden</span>
    <span class="kt">int</span> <span class="n">lastA</span> <span class="o">=</span> <span class="p">(</span><span class="n">aCnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">aArr</span><span class="p">[</span><span class="n">aCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">INT_MIN</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">lastB</span> <span class="o">=</span> <span class="p">(</span><span class="n">bCnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">bArr</span><span class="p">[</span><span class="n">bCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">INT_MIN</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lastA</span> <span class="o">&lt;</span> <span class="n">lastB</span><span class="p">)</span> <span class="c1">//ensure that lastA &gt;= lastB</span>
        <span class="k">return</span> <span class="n">Merge_ScalarBranchless_3</span><span class="p">(</span><span class="n">bArr</span><span class="p">,</span> <span class="n">bCnt</span><span class="p">,</span> <span class="n">aArr</span><span class="p">,</span> <span class="n">aCnt</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">aCap</span> <span class="o">=</span> <span class="n">aCnt</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">aCap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">aArr</span><span class="p">[</span><span class="n">aCap</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lastB</span><span class="p">)</span>
        <span class="n">aCap</span><span class="o">--</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">aCap</span> <span class="o">+</span> <span class="n">bCnt</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">aX</span> <span class="o">=</span> <span class="n">aArr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bX</span> <span class="o">=</span> <span class="n">bArr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">aX</span> <span class="o">&lt;</span> <span class="n">bX</span> <span class="o">?</span> <span class="nl">aX</span> <span class="p">:</span> <span class="n">bX</span><span class="p">);</span> <span class="c1">//cmov</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">aX</span> <span class="o">&lt;</span> <span class="n">bX</span><span class="p">);</span>               <span class="c1">//setXX</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">aX</span> <span class="o">&lt;</span> <span class="n">bX</span><span class="p">);</span>           <span class="c1">//setXX</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">aCnt</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">bCnt</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">aArr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">aCnt</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="p">(</span><span class="n">aCnt</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">bArr</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">bCnt</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bCnt</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="idea-of-vectorization"><a class="toclink" href="#idea-of-vectorization">Idea of vectorization</a></h2>
<p>The main problem with the merge algorithm is that it is inherently sequental. Before you finish comparison of two head elements, you cannot compare the next ones, you don't even know which two elements you have to compare next. This issue makes both scalar and vectorized code run slower, because instructions have to wait for each other to complete, and the compute units in CPU stay idle during this time.</p>
<p>Another problem is that the data is moved and shuffled in complex and dynamic ways during merging process. This is not noticeable in scalar implementation, because you operate on only two elements at a time. But if you want to vectorize merge operation, you have to work with more elements at once. If you take four elements from each array, you soon realize that these elements must be shuffled in one of 70 ways to get them into single sorted sequence. This is a big issue for vectorization, because it was mostly designed to do some simple <code>r[i] = a[i] + b[i]</code> things:</p>
<p><img src="https://dirtyhandscoding.github.io/images/1_avx2_merge/arithmetic_shuffling2.png" class="centered w600" /></p>
<p>Yes, SSE and AVX have many shuffling operations. But most of them accept only immediate operand (i.e. compile-time constant) as control mask, so they can only shuffle data in a static way. The rare exceptions are: <strong>pshufb</strong> (<a href="https://msdn.microsoft.com/en-us/library/bb531427.aspx">_mm_shuffle_epi8</a>) from SSSE3, <strong>vpermilpd</strong> and <strong>vpermilps</strong> (<a href="https://software.intel.com/en-us/node/524161">_mm256_permutevar_p?</a>) from AVX, and <strong>vpermd</strong> and <strong>vpermps</strong> (<a href="https://software.intel.com/en-us/node/524011">_mm256_permutevar8x32_*</a>) from AVX2. The first two can only shuffle data within 128-bit blocks, but the last one can shuffle eight 32-bit integers within 256-bit register in arbitrary way, which should allow us to merge 4 + 4 elements in one iteration.</p>
<p>Constructing shuffle control mask directly in the code is possible, but this is often too complex, and thus too slow. This is where lookup table (LUT) comes into play. The generic approach looks like this:
<ol>
  <li>Obtain enough information about input (f.i. by comparing elements), so that the needed shuffle control mask could be uniquely determined from this information.</li>
  <li>Convert information into compact bitmask in general purpose register (usually done by some shuffling and <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=movemask">movemask</a> intrinsic).</li>
  <li><em>(optional)</em> Apply <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash function</a> (e.g. some <a href="https://stackoverflow.com/a/41537995/556899">multiplicative hash</a>) to bitmask to obtain number of smaller size.</li>
  <li>Use obtained number as index in a lookup table. The corresponding element of the table must contain the desired control mask for shuffling (precomputed beforehand).</li>
</ol>
If this sounds complicated, just wait a bit: in the next section all of these steps will be thoroughly explained on example.</p>
<p>Speaking of our particular merging problem, we will use this approach to process four input elements per iteration. Suppose that from each input array, four minimal elements are loaded into xmm register. First of all, we merge these eight elements into a single sorted sequence. First half of the resulting sequence (4 elements) can be stored to the destination array immediately. The second half should remain in processing, because some future input elements can still be less than them.</p>
<p>An important question here is: how to move pointers in the input arrays? What are we going to load and process on the next iteration? Two approaches come into mind (see pictures below):
<ol>
  <li>Move each input pointer by number of its elements written to destination array (i.e. by how many elements from input array got into the four minimal elements of the sorted eight-element sequence). It means one of: move each pointer by two elements, move only one pointer by four elements, or move one pointer by three and the other pointer by one. On the next iteration, we'll simply load four elements again from each array using corresponding moved pointer.
This approach has many drawbacks: we have to use unaligned loads for input arrays, we have to load each input element twice on average, and we have to spend additional time on computing the pointer movements. Moreover, it is hard to learn what exactly we must load for the next iteration until we have fully sorted the eight elements on the current iteration: this makes dependency chain quite long.
Here is an illustration:</li></p>
<p><img src="https://dirtyhandscoding.github.io/images/1_avx2_merge/move_both_sum4.png" class="centered w600" />
  <li><em>(taken).</em> Move one input pointer by exactly four elements, leave the other one unchanged. When choosing which pointer to move, look where the last element considered is less: it should be moved. Let it be e.g. from the input array B; then on the next iteration the next four elements from B must be loaded and processed. We cannot use the same four elements from A on the next iteration, because some of them may already be dumped to the destination array. So we take the second half of the sorted eight-element sequence from the current iteration to be used as four elements from A on the next iteration (these are exactly the elements loaded from A and B which are not yet dumped to the destination array).
The core advantage here is that we can determine which pointer to move without waiting for the eight-element sorted sequence to be computed. It means that CPU will load the data for the next iteration and compare/sort the current data in parallel.</p>
<p><img src="https://dirtyhandscoding.github.io/images/1_avx2_merge/move_one4_nolegend.png" class="centered w600" />
</li>
</ol></p>
<h2 id="implementation"><a class="toclink" href="#implementation">Implementation</a></h2>
<p>Assume for simplicity that all input elements are distinct: then there is unique order in which the elements must go in the merged sequence. Let's suppose that we already have four elements from A loaded into <code>srcA</code>, and four elements of B loaded into <code>srcB</code> (both are xmm registers).</p>
<p>Here is an illustration for steps 1-4 and step A:</p>
<p><img src="https://dirtyhandscoding.github.io/images/1_avx2_merge/sort_4x4.png" class="centered w700" /></p>
<p><strong>Step 1.</strong> It is enough to compare all elements from <code>srcA</code> with all elements from <code>srcB</code> to fully determine their order in the common sorted sequence. In fact, the position of element <code>srcA[i]</code> in the final sorted array is equal to number of elements from <code>srcB</code> less than it plus its index <code>i</code>. If AVX2 had shuffling instruction which accepts scatter-style indices, we could even construct shuffle control mask directly without LUT using this property =) Unfortunately, SSE/AVX shuffles accept only gather-style indices.</p>
<p>This means we need to perform 16 comparisons (4 x 4) in total. Clearly, we can do four comparisons in single instruction, then rotate one of the registers by one element and compare again, and then repeat it two more times --- as the result, we'll get four xmm registers with comparison results bitmasks.</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask0</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">srcB</span><span class="p">);</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask1</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask3</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
</pre></div>


<p><strong>Step 2.</strong> Sixteen comparisons means that we should be able to get 16-bit mask, where each bit corresponds to the result of single comparison. In order to achieve this, we pack all the four bitmasks obtained on the previous step into single xmm register, where each byte contains result of one comparison. Using intrinsic <a href="https://msdn.microsoft.com/en-us/library/k4y4f7w5(v=vs.100).aspx">_mm_packs_epi16</a> three times does this exactly. Then apply <a href="https://msdn.microsoft.com/ru-ru/library/s090c8fk(v=vs.90).aspx">_mm_movemask_epi8</a> to the result: it gets sign bits of all 16 bytes and puts them into single 16-bit mask in general purpose register.</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask01</span> <span class="o">=</span> <span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">mask0</span><span class="p">,</span> <span class="n">mask1</span><span class="p">);</span>
<span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask23</span> <span class="o">=</span> <span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">mask3</span><span class="p">);</span>
<span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">mask01</span><span class="p">,</span> <span class="n">mask23</span><span class="p">);</span>
<span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="kt">uint32_t</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</pre></div>


<p><strong>Step 3.</strong> The obtained 16-bit bitmask can be used directly to load control mask from a lookup table. However, such a lookup table would take 65536 x 32 B = 2 MB of space, and the algorithm would read randomly some of its entries. This would waste precious TLB entries, so it would be great to compress this LUT somehow.</p>
<p>First we need to understand how many entries are really used in the table. Notice that each 16-bit mask determines precisely the ordering of all eight elements and vice versa (recall: all elements are distinct for now). Given that each set of four elements is sorted, each global ordering corresponds to a coloring of eight things into black and white, so that four things are colored in each color. This is binomial coefficient C(8,4) = 70. So only 70 bitmasks of 65536 are really possible as values of <code>bits</code> variable.</p>
<p>Now we want to create a hash function which maps valid bitmasks into integers from 0 to K-1, so that K is quite small (a bit greater than 70), hash function is perfect (i.e. gives no collisions) and blazingly fast to compute. Multiplicative hash function fits well under these criteria:
<p align="center">
<span class="math">\(f(x) = \left\lceil \frac{A \cdot x}{2^{32-b}} \right\rceil;\)</span>  where  <span class="math">\(x \in [0 \ldots 2^{32}), A \in (0 \ldots 2^{32}), b \in [0 \ldots 32)\)</span>.
</p>
For the problem considered, there is such a hash function for <code>b = 7</code> and <code>A = 0x256150A9</code>. The code for its usage is:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>   <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">*</span> <span class="mh">0x256150A9U</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">);</span>
<span class="p">[</span><span class="mi">10</span><span class="p">]</span>  <span class="n">__m256i</span> <span class="n">perm</span> <span class="o">=</span> <span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)</span><span class="n">lookupTable</span><span class="p">)[</span><span class="n">hash</span><span class="p">];</span>
</pre></div>


<p>This also finishes <strong>step 4</strong> from the generic description above.</p>
<p><strong>LUT generation.</strong> This part can easily take more time and more code than the whole merging algorithm =) But in its essence, it is just a small exercise in algorithmic programming. I'll only outline how it is done, you can look at the full code at the end of the article if you want.</p>
<ol>
  <li>Iterate through all 8-bit bitmasks with exactly 4 bits set: the i-th bit says from which input array i-th element in the sorted sequence comes (in fact this is an even coloring of eight elements into two colors). For each of them:
  <ol>
    <li>Assign numbers e.g. from 0 to 7 to the elements, so that they go in proper order according to the coloring. Note that exact values of the elements do not matter, only their ordering does.</li>
    <li>Generate 16-bit bitmask by doing all pairwise comparisons between the elements from each input array exactly as you do it in the merging algorithm (4 x 4 comparisons, one bit generated by each of them). This is the key for LUT.</li>
    <li>Generate the desired shuffle control mask which you need to use in this exact case to get the sorted sequence. This is the value for LUT.</li>
    <li>Dump all 70 key-value pairs into an array.</li>
  </ol></li>
  <li>Generate perfect hash function of the form shown above for the keys. For a fixed value of <code>b</code> (for instance, <code>b = 7</code>), iterate over all values of <code>A</code>. For each value, apply hash function to all the 70 keys and check for collisions. If there are no collisions, then you are done; otherwise, try the next value of <code>A</code>. This step took about a minute of computing time on my laptop.</li>
  <li>Apply the generated hash function to each key, and save corresponding value into the entry of lookup table with the obtained index.</li>
  <li>Dump the obtained lookup table into a text file in C++-compilable format. Then copy/paste its contents into your C++ file, so that you don't have to generate this data each time during program startup.</li>
</ol>

<p><strong>Step A.</strong> Now we have to apply this magic shuffling intrinsic <code>_mm256_permutevar8x32_epi32</code>. Since we have input elements in two separate xmm registers, we have to combine them first. Also, we have to split the result into two halves afterwards.</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>  <span class="n">__m256i</span> <span class="n">allSrc</span> <span class="o">=</span> <span class="n">_mm256_setr_m128i</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">srcB</span><span class="p">);</span>
<span class="p">[</span><span class="mi">12</span><span class="p">]</span>  <span class="n">__m256i</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">_mm256_permutevar8x32_epi32</span><span class="p">(</span><span class="n">allSrc</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
<span class="p">[</span><span class="mi">13</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">sortedLow</span> <span class="o">=</span> <span class="n">_mm256_castsi256_si128</span><span class="p">(</span><span class="n">sorted</span><span class="p">);</span>  <span class="c1">//nop</span>
<span class="p">[</span><span class="mi">14</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">sortedHigh</span> <span class="o">=</span> <span class="n">_mm256_extractf128_si256</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>Note that the elements from the lower half can be stored immediately into the destination array:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>  <span class="n">_mm_store_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">sortedLow</span><span class="p">);</span>
<span class="p">[</span><span class="mi">16</span><span class="p">]</span>  <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</pre></div>


<p><strong>Step B.</strong> Finally, we have to move the pointers in the input arrays. More precisely, we want to move only one pointer by 4 elements, depending on how the last elements in <code>srcA</code> and <code>srcB</code> compare to each other. We want to avoid branches (not to waste CPU time) and memory accesses (to keep latency low).</p>
<p>I must admit that there are a lot of ways to achieve it, and tons of possible code snippets that do it. Moreover, each snippet may compile to different assembly code, depending on exact choice of intrinsics and bitness/signedness of integer variables. I'll just describe the approach which worked best for me among numerous tries I did.</p>
<p>There are two pointers <code>ptrA</code> and <code>ptrB</code>: each of them moves along one of the input arrays. To simplify code, we want to sometimes swap these two pointers, so that one specific pointer (e.g. <code>ptrB</code>) is always moved. Unfortunately, it is quite hard to efficiently swap two registers on condition in branchless fashion, but it becomes easier if we maintain address difference <code>abDiff = ptrB - ptrA</code> instead of the pointer <code>ptrB</code>. In such case swapping is equivalent to <code>ptrA = ptrA + abDiff</code> and <code>abDiff = -abDiff</code>.</p>
<p>First of all, recall that we have already compared 3-rd elements of <code>srcA</code> and <code>srcB</code>, and the result is saved in <code>mask0</code> register. Let's extract it from there into GP register:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>  <span class="kr">__m128i</span> <span class="n">mask0last</span> <span class="o">=</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">mask0</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">[</span><span class="mi">18</span><span class="p">]</span>  <span class="kt">size_t</span> <span class="n">srcAless</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_sz</span><span class="p">(</span><span class="n">mask0last</span><span class="p">);</span>
</pre></div>


<p><code>_mm_cvtsi128_sz</code> is a macro for <a href="https://msdn.microsoft.com/en-us/library/5z7a9642(v=vs.90).aspx">_mm_cvtsi128_si32</a> or <a href="https://msdn.microsoft.com/en-us/library/bb531384(v=vs.120).aspx">_mm_cvtsi128_si64</a>, depending on bitness.</p>
<p>Then we want to swap pointers if <code>srcAless = -1</code>, and retain their values if <code>srcAless = 0</code>. The following ugly piece of code achieves that in 4 instructions:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">19</span><span class="p">]</span>  <span class="n">aPtr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">(</span><span class="n">aPtr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">abDiff</span> <span class="o">&amp;</span> <span class="n">srcAless</span><span class="p">));</span>
<span class="p">[</span><span class="mi">20</span><span class="p">]</span>  <span class="n">abDiff</span> <span class="o">^=</span> <span class="n">srcAless</span><span class="p">;</span>  <span class="n">abDiff</span> <span class="o">-=</span> <span class="n">srcAless</span><span class="p">;</span>
</pre></div>


<p>Now the 3-rd element from <code>ptrA</code> is surely greater, so we have to move the <code>ptrB</code> pointer. Since we do not maintain <code>ptrB</code>, we have to increase <code>abDiff</code> instead:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">21</span><span class="p">]</span>  <span class="n">abDiff</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>After that we load four new elements from <code>ptrB</code> (do not forget that the pointer must be computed):</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">22</span><span class="p">]</span>  <span class="n">bPtr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">(</span><span class="n">aPtr</span><span class="p">)</span> <span class="o">+</span> <span class="n">abDiff</span><span class="p">);</span>
<span class="p">[</span><span class="mi">23</span><span class="p">]</span>  <span class="n">srcB</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">bPtr</span><span class="p">);</span>
</pre></div>


<p>According to the plan (see above), we must use higher half of the sorted sequence in place of the elements from array A on the next step, so:</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">24</span><span class="p">]</span>  <span class="n">srcA</span> <span class="o">=</span> <span class="n">sortedHigh</span><span class="p">;</span>
</pre></div>


<p>The description of the vectorized implementation ends here.</p>
<p><strong>Full code.</strong> All the code snippets gathered above can be combined to get a working merge function:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Merge_Simd_KeysOnly</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">aCnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bCnt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//merge input arrays in reverse direction (from ends)</span>
    <span class="kt">intptr_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">aCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">bCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">aCnt</span> <span class="o">+</span> <span class="n">bCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">aCnt</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bCnt</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bArr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">bArr</span><span class="p">[</span><span class="n">j</span><span class="o">--</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">aArr</span><span class="p">[</span><span class="n">i</span><span class="o">--</span><span class="p">];</span>
        <span class="c1">//TODO: any vectorized code if loop does not finish soon?</span>
    <span class="p">}</span>
    <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">//these cases are necessary to ensure that arrays are long enough</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">bArr</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="k">return</span> <span class="n">aCnt</span> <span class="o">+</span> <span class="n">bCnt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">aArr</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="k">return</span> <span class="n">aCnt</span> <span class="o">+</span> <span class="n">bCnt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//prepare for the first iteration</span>
    <span class="kt">size_t</span> <span class="n">maxK</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">aCnt</span> <span class="o">+</span> <span class="n">bCnt</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aPtr</span> <span class="o">=</span> <span class="n">aArr</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bPtr</span> <span class="o">=</span> <span class="n">bArr</span><span class="p">;</span>
    <span class="kt">intptr_t</span> <span class="n">abDiff</span> <span class="o">=</span> <span class="kt">intptr_t</span><span class="p">(</span><span class="n">bArr</span><span class="p">)</span> <span class="o">-</span> <span class="kt">intptr_t</span><span class="p">(</span><span class="n">aArr</span><span class="p">);</span>
    <span class="kr">__m128i</span> <span class="n">srcA</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">aPtr</span><span class="p">);</span>
    <span class="kr">__m128i</span> <span class="n">srcB</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">bPtr</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxK</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//inner-loop: combined from all the snippets</span>
        <span class="kr">__m128i</span> <span class="n">mask0</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">srcB</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">mask1</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
        <span class="kr">__m128i</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="kr">__m128i</span> <span class="n">mask3</span> <span class="o">=</span> <span class="n">_mm_cmplt_epi32</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">srcB</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
        <span class="kr">__m128i</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">mask0</span><span class="p">,</span> <span class="n">mask1</span><span class="p">),</span> <span class="n">_mm_packs_epi16</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">mask3</span><span class="p">));</span>
        <span class="kt">uint32_t</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

        <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">*</span> <span class="mh">0x256150A9U</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">);</span>
        <span class="n">__m256i</span> <span class="n">perm</span> <span class="o">=</span> <span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)</span><span class="n">lookupTable</span><span class="p">)[</span><span class="n">hash</span><span class="p">];</span>

        <span class="n">__m256i</span> <span class="n">allSrc</span> <span class="o">=</span> <span class="n">_mm256_setr_m128i</span><span class="p">(</span><span class="n">srcA</span><span class="p">,</span> <span class="n">srcB</span><span class="p">);</span>
        <span class="n">__m256i</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">_mm256_permutevar8x32_epi32</span><span class="p">(</span><span class="n">allSrc</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">sortedLow</span> <span class="o">=</span> <span class="n">_mm256_castsi256_si128</span><span class="p">(</span><span class="n">sorted</span><span class="p">);</span>
        <span class="kr">__m128i</span> <span class="n">sortedHigh</span> <span class="o">=</span> <span class="n">_mm256_extractf128_si256</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

        <span class="kt">size_t</span> <span class="n">srcAless</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_sz</span><span class="p">(</span><span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">mask0</span><span class="p">,</span> <span class="n">SHUF</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)));</span>
        <span class="c1">//conditionally swap ptrA and ptrB (abDiff)</span>
        <span class="n">aPtr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">(</span><span class="n">aPtr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">abDiff</span> <span class="o">&amp;</span> <span class="n">srcAless</span><span class="p">));</span>
        <span class="n">abDiff</span> <span class="o">^=</span> <span class="n">srcAless</span><span class="p">;</span>  <span class="n">abDiff</span> <span class="o">-=</span> <span class="n">srcAless</span><span class="p">;</span>

        <span class="n">abDiff</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
        <span class="n">bPtr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">(</span><span class="n">aPtr</span><span class="p">)</span> <span class="o">+</span> <span class="n">abDiff</span><span class="p">);</span>
        <span class="n">srcA</span> <span class="o">=</span> <span class="n">sortedHigh</span><span class="p">;</span>
        <span class="n">srcB</span> <span class="o">=</span> <span class="n">_mm_load_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">bPtr</span><span class="p">);</span>

        <span class="n">_mm_store_si128</span><span class="p">((</span><span class="kr">__m128i</span><span class="o">*</span><span class="p">)(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="n">sortedLow</span><span class="p">);</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">aCnt</span> <span class="o">+</span> <span class="n">bCnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="generality"><a class="toclink" href="#generality">Generality</a></h2>
<h3 id="equal-elements"><a class="toclink" href="#equal-elements">Equal elements</a></h3>
<p>The algorithm (and the code) works properly even if equal elements are present. It can be checked using the "perturbation method", which is sometimes used to resolve singular cases in computational geometry.</p>
<p>Imagine that <code>eps</code> is a small positive number much less than 1. Consider packs <code>srcA</code> and <code>srcB</code> with four integers in each. Add <code>i*eps</code> to <code>srcA[i]</code> and subtract <code>j*eps</code> from <code>srcB[j]</code>. This perturbation does not change the masks generated during step 1 of the algorithm, because we do only comparisons of style "A[i] &lt; B[j]" there. The code works properly for perturbed elements (because they are distinct), and it will shuffle the original elements in exactly the same way, so after step 4 we'll get properly sorted eight-element sequence.</p>
<p>The last thing to note is that when we choose which pointer to move, we can choose any of the two if their last elements are equal (just as we do in the ordinary scalar merge if elements are equal).</p>
<h3 id="key-value-pairs"><a class="toclink" href="#key-value-pairs">Key-value pairs</a></h3>
<p>It is rather easy to extend the code to work with 32-bit values attached to 32-bit keys. The idea is to store four values in register <code>valuesA</code> for the four keys stored in register <code>srcA</code>, and do the same for array B. All the data movement happening on the keys must be exactly reproduced on the values too.</p>
<p>The lines 1-10 of the code listing are only gathering information about keys, so they can be left untouched. The lines 11-14 must be duplicated for the values with the same shuffle control mask.</p>
<p>If keys and values are provided in separate arrays (<a href="https://en.wikipedia.org/wiki/AOS_and_SOA">SoA layout</a>), then lines 19-22 must also be duplicated, since values would have their own pointer into array A and difference between pointer addresses. And this is rather unfortunate, because it is a lot of instructions. On the other hand, lines 15 and 23 (load/store) can be simply duplicated without any changes.</p>
<p>If keys and values are interleaved (<a href="https://en.wikipedia.org/wiki/AOS_and_SOA">AoS layout</a>), then it becomes a bit simpler. Lines 11-14 can be left untouched, but loads and stores in lines 15 and 23 must be accompanied with some shuffling to interleave/deinterleave keys and values (in addition to duplication, of course).</p>
<h2 id="performance"><a class="toclink" href="#performance">Performance</a></h2>
<p>For testing performance, two integer sequences of length <em>N</em> were generated, each element is random with uniform distribution from 0 to 3*<em>N</em>. After that both of the sequences were sorted. Then all the methods were run on these two input arrays, each method was run many times in a row. Note that each run was done on the same input, and it is very important especially for small <em>N</em>, where branch predictor can simply memorize everything. Total elapsed time was measured, and average time in nanoseconds per one output element was computed. This time is shown in this table:
<img src="https://dirtyhandscoding.github.io/images/1_avx2_merge/perfo_table.png" class="centered w600" />
Five implementations were tested:
<ul>
  <li><strong>Simd</strong>: vectorized version based on SSE/AVX2 (Merge_Simd_KeysOnly function described in the article)</li>
  <li><strong>Br.-less</strong>: scalar version without branches (see Merge_ScalarBranchless_3 function listing)</li>
  <li><strong>Opt.</strong>: optimized scalar version with branches (not shown in the article)</li>
  <li><strong>Triv.</strong>: baseline scalar version with branches (see Merge_ScalarTrivial function listing)</li>
  <li><strong>std::</strong>: direct call to std::merge (scalar, with branches)</li>
</ul></p>
<p>Note that only the first two implementations were thoroughly optimized. That's why e.g. "<strong>Triv.</strong>" performance is so different on 32-bit vs 64-bit. Most likely I did not inspect the assembly output, so there are some excessive 32/64-bit conversions, which normally does not affect performance, but in such tiny loops it becomes very important.</p>
<p>Although results for <em>N</em> = 1K are provided, they have little sense actually. I'm pretty sure that branch predictor simply memorized how the elements compare to each other, that's why scalar implementations with branches become so fast. In the real world, the input sequences would be different each time, so the performance results would be different too.</p>
<p>I was testing GCC in VirtualBox VM, and I hope that it does not affect the results too much. Speaking of MSVC vs GCC comparison, the first two implementations work equally well on them.</p>
<p>Brand new AMD Ryzen CPU and mobile Intel CPU (broadwell) were used for performance measurements. The two main implementations are branchless, and they work almost the same way on both processors. The one really interesting thing here is that the solutions with branches for <em>N</em> = 1K work a lot better on Ryzen then on Broadwell. I suppose the well-marketed branch predictor based on neural net does its job well and memorizes all the branches, unlike its Intel counterpart =)</p>
<hr />

<p><a href="https://gist.github.com/stgatilov/ac832c6dd30e695e566f42b1ef8ef45a#file-merge-cpp">All the code is available in this gist</a>
(both merge implementations and lookup table generator).</p>
<hr />

<h2 id="conclusion"><a class="toclink" href="#conclusion">Conclusion</a></h2>
<p>The vectorized version is 1.8 times faster than the scalar branchless version, and 2.3 times faster than std::merge. Is such a speedup worth all the trouble?! I think not =)</p>
<p>A related but simpler problem is set intersection problem: find all common elements in two strictly increasing arrays. A vectorized solution for it (very similar to the algorithm described in this article) is described in <a href="https://highlyscalable.wordpress.com/2012/06/05/fast-intersection-sorted-lists-sse/">this blog post</a>, and its optimized version is available <a href="https://github.com/lemire/SIMDCompressionAndIntersection/blob/master/src/intersection.cpp#L1196">here</a>.</p>
<p>You might ask: <em>why is the performance improvement from vectorization so low?</em> is it because of lookup table or something else?
I think I'll save these questions for another post =)
Aside from some analysis of the code shown here, I'll try to implement merge sort on top of it. I wonder if I could beat std::sort with it...</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
      
    </div><!-- /.entry-content -->
    <section>
        <div id="post-share-links" class="inline-menu">
            <div>Share on:</div>
            <a href="https://twitter.com/intent/tweet?text=Vectorizing%20std%3A%3Amerge%20with%20vpermd%20from%20AVX2%20and%20lookup%20table&url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share on Twitter">Twitter</a><!--
            --><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share on Facebook">Facebook</a><!--
            --><a href="https://plus.google.com/share?url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share on Google Plus">Google+</a><!--
            --><a href="https://sharetodiaspora.github.io/?title=Vectorizing%20std%3A%3Amerge%20with%20vpermd%20from%20AVX2%20and%20lookup%20table&url=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share on Diaspora">Diaspora*</a><!--
            --><a href="https://news.ycombinator.com/submitlink?t=Vectorizing%20std%3A%3Amerge%20with%20vpermd%20from%20AVX2%20and%20lookup%20table&u=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share on HackerNews">HackerNews</a><!--
            --><a href="mailto:?subject=Vectorizing%20std%3A%3Amerge%20with%20vpermd%20from%20AVX2%20and%20lookup%20table&amp;body=https%3A//dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html" target="_blank" class="icon-label" title="Share via Email">Email</a>
        </div>
    </section>
    
    			<!--<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.4.min.js"></script>-->
		<script src="https://dirtyhandscoding.github.io/theme/js/jquery.min.js"></script>
	<script type="text/javascript" src="https://dirtyhandscoding.github.io/theme/pelican_comment_system/comments.js"></script>
	<script type="text/javascript">
		$(document).ready(function() {
			CommentSystem.email_user   = "itiswrongemail";
			CommentSystem.email_domain = "outlook.com";

			$('#pcs-comment-form').on("submit",
				function( event )
				{
					event.preventDefault();
					$(location).attr('href', CommentSystem.getMailtoLink("vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table"));
				}
			);
		});
	</script>

    	<section>
	<div id="pcs-comments-header" class="inline-menu">
	<header>
		<div>Comments (3)</div>
		<button type="button" title="Expand or collapse the comments section" class="icon-label" id="pcs-comments-collapse-button" onclick="CommentSystem.collapsible($('#pcs-comments'), $(this));">
			<span class="nocss">expand</span>
		</button>
			<a href="https://dirtyhandscoding.github.io/feeds/comment.vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.atom.xml" class="icon-label">atom feed: comments</a>
	</header>
	</div>
	<div id="pcs-comments">
		<ul>
			<li id="comment-1md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\4c80262a2ba67530ecaa6dd1edf1f9b6.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-1md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('1md', 'Morwenn');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							Morwenn
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-26T19:29:00+07:00" title="2017-08-26T19:29:00+07:00">(26.08.2017 at 19:29)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>Hi, I found your article very interesting (and being a code-stealer, I might borrow some ideas to improve some of my algorithms). I also tried to improve a simple merge algorithm once or twice, and came up with a few tricks. Condiering how smart some of the ideas you describe are, I’m surprised that you didn’t describe one the simplest tricks I use: since we know the size of the collections, we know that we will have to move at least <code>min(aCnt, bCnt)</code> elements from each of the original collections, so we can do a blind loop from <code>0</code> to <code>min(aCnt, bCnt)</code>, then the usual loop that checks for <code>i &lt; aCnt &amp;&amp; j &lt; bCnt</code>. In order to do that, I actually copy pointers that I increment instead of incrementing the indices, so it's a bit different. I feel that I suck at explaining, so you could just have a look at the code at the end of the algorithm. The trick ensures that the first loop condition is trivial rather than repeatedly checking for the values of <code>i</code> and <code>j</code> that are unpredictable at every iteration.</p>
<p>Anyway, that was a great article; really interesting. Kudos! </p>
<p><a href="https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97">https://github.com/Morwenn/cpp-sort/blob/master/include/cpp-sort/detail/inplace_merge.h#L58-L97</a></p>
					</div>
					</div>
						<!--<hr>-->
						<ul>
										<li id="comment-2md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\f34da67b9f39c15787aa7a9e932509bc.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-2md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('2md', 'dirtyhandscoding');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self odd">
					<h4>
							dirtyhandscoding
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-27T19:38:00+07:00" title="2017-08-27T19:38:00+07:00">(27.08.2017 at 19:38)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>I’m glad you liked it!</p>
<p>Yes, you can merge the first <code>min(aCnt, bCnt)</code> elements without checking where the pointers are, and then use slower <code>i &lt; aCnt &amp;&amp; j &lt; bCnt</code> condition for the rest of the work. For the most likely case of equally-sized arrays, it would cope only with 50% of the issue (regardless of elements order). I guess my perfectionism does not like that =) The things I suggested fix the problem almost completely, except for maybe pathologically ordered inputs.</p>
<p>Hopefully I'll implement merge sort on top of the suggested merge algorithm, but I'm afraid it won't happen soon =(</p>
					</div>
					</div>
						<!--<hr>-->
						<ul>
										<li id="comment-3md">
				<div class="comment-left">
					<img    src="https://dirtyhandscoding.github.io/images/identicon\4c80262a2ba67530ecaa6dd1edf1f9b6.png"
							alt="Avatar"
							height="36"
							width="36">
					<a role="button" href="https://dirtyhandscoding.github.io/posts/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.html#comment-3md" rel="bookmark" title="Link to this comment" class="comment-left-icon">
						<span class="nocss">link</span>
					</a><!--
					--><button onclick="CommentSystem.setReply('3md', 'Morwenn');" title="Reply to this comment" class="comment-left-icon">
						<span class="nocss">reply</span>
					</button>
				</div>
				<div class="comment-body">
					<div class="comment-self even">
					<h4>
							Morwenn
					</h4>
					<!-- <p>
						Posted on -->
						<div style="float: right">
						<time datetime="2017-08-27T23:07:00+07:00" title="2017-08-27T23:07:00+07:00">(27.08.2017 at 23:07)</time>
						</div>
					<!-- </p> -->
					<div class="pcs-comment-content" >
						<p>In the end, your taken solution goes in the same way, but further, truly solves the problem. At first I was surprised that you didn’t use a binary search to find the greatest element of a collection in the other collection, but your latest post pretty much covers the linear vs binary search question.</p>
<p>I’m surprised that your branchless implementation is faster though, considering that the last time I tried to make a branchless merge, it was terribly slower than branchy version (see SO post). That said, after having read your post, it becomes clearer: the loop condition still depended on the result of the loop, so the branch wasn’t the main issue in the first place. I should try it again.</p>
<p>Anyway, if you ever write that mergesort article, I’ll be happy to read it ^^</p>
<p><a href="https://stackoverflow.com/q/41129442/1364752">https://stackoverflow.com/q/41129442/1364752</a></p>
					</div>
					</div>
				</div>
			</li>

						</ul>
				</div>
			</li>

						</ul>
				</div>
			</li>
		</ul>
	<section>
	<div display="none" id="pcs-comment-notreply-helper" />
	<form id="pcs-comment-form" action="#">
		<fieldset>
		<legend>Add a Comment</legend>
		<div id="pcs-comment-tab-inputs">
			<input type="hidden" id="pcs-comment-form-input-replyto"/>
			<label for="pcs-comment-form-input-name">Name</label>
			<input  id="pcs-comment-form-input-name" type="text" size="40" placeholder="Enter your name or nickname" />
			<br/>
			<label for="pcs-comment-form-input-website">Website</label>
			<input  id="pcs-comment-form-input-website" type="text" size="40" placeholder="Enter your website (optional)" />
			<br/>
			<label for="pcs-comment-form-input-empty">Empty</label>
			<input  id="pcs-comment-form-input-empty" type="text" size="30" placeholder="Do NOT enter anything here!" />
			<label   for="pcs-comment-form-input-textarea">Your Comment</label>
			<br/>
			<textarea id="pcs-comment-form-input-textarea" rows="7" cols="40" placeholder="Enter your comment (markdown is allowed)"></textarea>
		</div>
		<div id="pcs-comment-tab-message" style="display:none">
			<textarea readonly rows="10" cols="40"></textarea>
		</div>

		<button type="submit"
				id="pcs-comment-form-button-submit"
				title="Create mailto link and open it in default email client &#10;Note: you have to send the email to post comment"
				>Post via email</button>
		<button type="button"
				id="pcs-comment-form-button-message"
				title="See the text of email message to be sent &#10;Note: you can copy it and send manually"
				onclick="CommentSystem.viewEmail(&quot;vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table&quot;);"
				>View email text</button>
		<a target="_blank"
				id="pcs-comment-gmail-config-help"
				title="How to configure Chrome to open mailto links in Gmail..."
				href="https://productforums.google.com/forum/#!topic/gmail/JtWVPbUfh-o"
				>?</a>
		</fieldset>

		<!--			<a href="https://dirtyhandscoding.github.io/feeds/comment.vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table.atom.xml">
				Comment Atom Feed
			</a>
-->
	</form>
	<script>CommentSystem.displayReplyTo();</script>
</section>

	</div>
	<script>
		$('#pcs-comments').css({display: "none"});
		$('#pcs-comments-collapse-button').addClass('collapsed');
	</script>
</section>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, customized to personal taste.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>